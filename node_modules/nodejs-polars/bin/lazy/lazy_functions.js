"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.list = exports.tail = exports.spearmanRankCorr = exports.select = exports.quantile = exports.pearsonCorr = exports.nUnique = exports.median = exports.mean = exports.last = exports.head = exports.groups = exports.format = exports.first = exports.exclude = exports.cov = exports.count = exports.concatString = exports.concatList = exports.avg = exports.argSortBy = exports.arange = exports.lit = exports.cols = exports.col = void 0;
const expr_1 = require("./expr");
const series_1 = require("../series");
const dataframe_1 = require("../dataframe");
const utils_1 = require("../utils");
const polars_internal_1 = __importDefault(require("../internals/polars_internal"));
function col(col) {
    if ((0, utils_1.isSeries)(col)) {
        col = col.toArray();
    }
    if (Array.isArray(col)) {
        return (0, expr_1.Expr)(polars_internal_1.default.cols({ name: col }));
    }
    else {
        return (0, expr_1.Expr)(polars_internal_1.default.col({ name: col }));
    }
}
exports.col = col;
function cols(col1, ...cols) {
    cols.unshift(col1);
    return col(cols);
}
exports.cols = cols;
function lit(value) {
    if (Array.isArray(value)) {
        value = (0, series_1.Series)(value);
    }
    if ((0, utils_1.isSeries)(value)) {
        return (0, expr_1.Expr)(polars_internal_1.default.lit({ value: value._series }));
    }
    return (0, expr_1.Expr)(polars_internal_1.default.lit({ value }));
}
exports.lit = lit;
function arange(opts, high, step, eager) {
    if (typeof opts?.low === "number") {
        return arange(opts.low, opts.high, opts.step, opts.eager);
    }
    else {
        const low = (0, expr_1.exprToLitOrExpr)(opts, false);
        high = (0, expr_1.exprToLitOrExpr)(high, false);
        if (eager) {
            const df = (0, dataframe_1.DataFrame)({ "a": [1] });
            return df.select(arange(low, high, step).alias("arange")).getColumn("arange");
        }
        return (0, expr_1.Expr)(polars_internal_1.default.arange({ low: low._expr, high: high._expr, step }));
    }
}
exports.arange = arange;
/**
 * __Find the indexes that would sort the columns.__
 * ___
 * Argsort by multiple columns. The first column will be used for the ordering.
 * If there are duplicates in the first column, the second column will be used to determine the ordering
 * and so on.
 */
function argSortBy(exprs, reverse = false) {
    if (!Array.isArray(reverse)) {
        reverse = Array.from({ length: exprs.length }, () => reverse);
    }
    const by = (0, utils_1.selectionToExprList)(exprs);
    return (0, expr_1.Expr)(polars_internal_1.default.argSortBy({ by, reverse }));
}
exports.argSortBy = argSortBy;
function avg(column) {
    return mean(column);
}
exports.avg = avg;
function concatList(...exprs) {
    const items = (0, utils_1.selectionToExprList)(exprs, false);
    return (0, expr_1.Expr)(polars_internal_1.default.concatList({ items }));
}
exports.concatList = concatList;
function concatString(opts, sep = ",") {
    if (opts?.exprs) {
        return concatString(opts.exprs, opts.sep);
    }
    const items = (0, utils_1.selectionToExprList)(opts, false);
    return (0, expr_1.Expr)(polars_internal_1.default.concatString({ items, sep }));
}
exports.concatString = concatString;
function count(column) {
    if ((0, utils_1.isSeries)(column)) {
        return column.len();
    }
    else {
        return col(column).count();
    }
}
exports.count = count;
/** Compute the covariance between two columns/ expressions. */
function cov(a, b) {
    a = (0, expr_1.exprToLitOrExpr)(a, false)._expr;
    b = (0, expr_1.exprToLitOrExpr)(b, false)._expr;
    return (0, expr_1.Expr)(polars_internal_1.default.cov({ a, b }));
}
exports.cov = cov;
/**
 * Exclude certain columns from a wildcard expression.
 *
 * Syntactic sugar for:
 * ```
 * >>> pl.col("*").exclude(columns)
 * ```
 */
function exclude(column, ...columns) {
    return col("*").exclude(column, ...columns);
}
exports.exclude = exclude;
function first(column) {
    if ((0, utils_1.isSeries)(column)) {
        if (column.length) {
            return column[0];
        }
        else {
            throw new RangeError("The series is empty, so no first value can be returned.");
        }
    }
    else {
        return col(column).first();
    }
}
exports.first = first;
function format(strings, ...expr) {
    if (typeof strings === "string") {
        const s = strings.split("{}");
        if (s.length - 1 !== expr.length) {
            throw new RangeError("number of placeholders should equal the number of arguments");
        }
        return format(s, ...expr);
    }
    const d = (0, utils_1.range)(0, Math.max(strings.length, expr.length)).flatMap((i) => {
        const sVal = strings[i] ? lit(strings[i]) : [];
        const exprVal = expr[i] ? (0, expr_1.exprToLitOrExpr)(expr[i], false) : [];
        return [sVal, exprVal];
    })
        .flat();
    return concatString(d, "");
}
exports.format = format;
/** Syntactic sugar for `pl.col(column).aggGroups()` */
function groups(column) {
    return col(column).aggGroups();
}
exports.groups = groups;
function head(column, n) {
    if ((0, utils_1.isSeries)(column)) {
        return column.head(n);
    }
    else {
        return (0, expr_1.exprToLitOrExpr)(column, false).head(n);
    }
}
exports.head = head;
function last(column) {
    if ((0, utils_1.isSeries)(column)) {
        if (column.length) {
            return column[-1];
        }
        else {
            throw new RangeError("The series is empty, so no last value can be returned.");
        }
    }
    else {
        return (0, expr_1.exprToLitOrExpr)(column, false).last();
    }
}
exports.last = last;
function mean(column) {
    if ((0, utils_1.isSeries)(column)) {
        return column.mean();
    }
    return (0, expr_1.exprToLitOrExpr)(column, false).mean();
}
exports.mean = mean;
function median(column) {
    if ((0, utils_1.isSeries)(column)) {
        return column.median();
    }
    return (0, expr_1.exprToLitOrExpr)(column, false).median();
}
exports.median = median;
function nUnique(column) {
    if ((0, utils_1.isSeries)(column)) {
        return column.nUnique();
    }
    return (0, expr_1.exprToLitOrExpr)(column, false).nUnique();
}
exports.nUnique = nUnique;
/** Compute the pearson's correlation between two columns. */
function pearsonCorr(a, b) {
    a = (0, expr_1.exprToLitOrExpr)(a, false)._expr;
    b = (0, expr_1.exprToLitOrExpr)(b, false)._expr;
    return (0, expr_1.Expr)(polars_internal_1.default.pearsonCorr({ a, b }));
}
exports.pearsonCorr = pearsonCorr;
function quantile(column, q) {
    if ((0, utils_1.isSeries)(column)) {
        return column.quantile(q);
    }
    return (0, expr_1.exprToLitOrExpr)(column, false).quantile(q);
}
exports.quantile = quantile;
/**
 * __Run polars expressions without a context.__
 *
 * This is syntactic sugar for running `df.select` on an empty DataFrame.
 */
function select(expr, ...exprs) {
    return (0, dataframe_1.DataFrame)({}).select(expr, ...exprs);
}
exports.select = select;
/** Compute the spearman rank correlation between two columns. */
function spearmanRankCorr(a, b) {
    a = (0, expr_1.exprToLitOrExpr)(a, false)._expr;
    b = (0, expr_1.exprToLitOrExpr)(b, false)._expr;
    return (0, expr_1.Expr)(polars_internal_1.default.spearmanRankCorr({ a, b }));
}
exports.spearmanRankCorr = spearmanRankCorr;
function tail(column, n) {
    if ((0, utils_1.isSeries)(column)) {
        return column.tail(n);
    }
    else {
        return (0, expr_1.exprToLitOrExpr)(column, false).tail(n);
    }
}
exports.tail = tail;
/** Syntactic sugar for `pl.col(column).list()` */
function list(column) {
    return (0, expr_1.exprToLitOrExpr)(column, false).list();
}
exports.list = list;
// export function collect_all() {}
// export function all() {} // fold
// export function any() {} // fold
// export function apply() {} // lambda
// export function fold() {}
// export function map_binary() {} //lambda
// export function map() {} //lambda
// export function max() {} // fold
// export function min() {} // fold
// export function sum() {} // fold
