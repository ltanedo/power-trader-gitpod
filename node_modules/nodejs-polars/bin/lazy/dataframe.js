"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LazyDataFrame = void 0;
const dataframe_1 = require("../dataframe");
const expr_1 = require("./expr");
const utils_1 = require("../utils");
const polars_internal_1 = __importDefault(require("../internals/polars_internal"));
const groupby_1 = require("./groupby");
const LazyDataFrame = (ldf) => {
    const unwrap = (method, args, _ldf = ldf) => {
        return polars_internal_1.default.ldf[method]({ _ldf, ...args });
    };
    const wrap = (method, args, _ldf = ldf) => {
        return (0, exports.LazyDataFrame)(unwrap(method, args, _ldf));
    };
    const wrapNullArgs = (method) => () => wrap(method);
    const withOptimizationToggle = (method) => (lazyOptions) => {
        const ldf = unwrap("optimizationToggle", lazyOptions);
        return unwrap(method, {}, ldf);
    };
    return {
        _ldf: ldf,
        get columns() {
            return unwrap("columns");
        },
        describePlan: () => unwrap("describePlan"),
        describeOptimizedPlan: withOptimizationToggle("describeOptimizedPlan"),
        cache: wrapNullArgs("cache"),
        collectSync: () => (0, dataframe_1.dfWrapper)(unwrap("collectSync")),
        collect: () => unwrap("collect").then(dataframe_1.dfWrapper),
        drop: (...cols) => wrap("dropColumns", { cols: cols.flat(2) }),
        dropDuplicates(opts = true, subset) {
            if (opts?.maintainOrder !== undefined) {
                return this.dropDuplicates(opts.maintainOrder, opts.subset);
            }
            if (subset) {
                subset = [subset].flat(2);
            }
            return wrap("dropDuplicates", { maintainOrder: opts.maintainOrder, subset });
        },
        dropNulls(...subset) {
            if (subset.length) {
                return wrap("dropNulls", { subset: subset.flat(2) });
            }
            else {
                return wrap("dropNulls");
            }
        },
        explode(...columns) {
            if (!columns.length) {
                const cols = (0, utils_1.selectionToExprList)((0, exports.LazyDataFrame)(ldf).columns, false);
                return wrap("explode", { column: cols });
            }
            const column = (0, utils_1.selectionToExprList)(columns, false);
            return wrap("explode", { column });
        },
        fetch(numRows, opts) {
            if (opts?.noOptimization) {
                opts.predicatePushdown = false;
                opts.projectionPushdown = false;
            }
            if (opts) {
                const _ldf = unwrap("optimizationToggle", opts);
                return (0, dataframe_1.dfWrapper)(unwrap("fetchSync", { numRows }, _ldf));
            }
            return (0, dataframe_1.dfWrapper)(unwrap("fetchSync", { numRows }));
        },
        first() {
            return this.fetch(1);
        },
        fillNull(exprOrValue) {
            const fillValue = (0, expr_1.exprToLitOrExpr)(exprOrValue)._expr;
            return wrap("fillNull", { fillValue });
        },
        filter(exprOrValue) {
            const predicate = (0, expr_1.exprToLitOrExpr)(exprOrValue, false)._expr;
            return wrap("filter", { predicate });
        },
        groupBy(opt, maintainOrder = true) {
            if (opt?.by !== undefined) {
                return (0, groupby_1.LazyGroupBy)(ldf, opt.by, opt.maintainOrder);
            }
            return (0, groupby_1.LazyGroupBy)(ldf, opt, maintainOrder);
        },
        head: (len = 5) => wrap("slice", { offset: 0, len }),
        join(df, options) {
            options = {
                how: "inner",
                suffix: "right",
                allowParallel: true,
                forceParallel: false,
                ...options
            };
            const { how, suffix, allowParallel, forceParallel } = options;
            let leftOn;
            let rightOn;
            if (options.on) {
                const on = (0, utils_1.selectionToExprList)(options.on, false);
                leftOn = on;
                rightOn = on;
            }
            else if ((options.leftOn && !options.rightOn) || (options.rightOn && !options.leftOn)) {
                throw new TypeError("You should pass the column to join on as an argument.");
            }
            else {
                leftOn = (0, utils_1.selectionToExprList)(options.leftOn, false);
                rightOn = (0, utils_1.selectionToExprList)(options.rightOn, false);
            }
            return wrap("join", {
                other: df._ldf,
                how,
                leftOn,
                rightOn,
                suffix,
                allowParallel,
                forceParallel
            });
        },
        last: () => wrap("tail", { length: 1 }),
        limit: (len = 5) => wrap("slice", { offset: 0, len }),
        max: wrapNullArgs("max"),
        mean: wrapNullArgs("mean"),
        median: wrapNullArgs("median"),
        melt(ids, values) {
            return wrap("melt", {
                idVars: (0, utils_1.columnOrColumnsStrict)(ids),
                valueVars: (0, utils_1.columnOrColumnsStrict)(values)
            });
        },
        min: wrapNullArgs("min"),
        quantile: (quantile) => wrap("quantile", { quantile }),
        rename(mapping) {
            const existing = Object.keys(mapping);
            const replacements = Object.values(mapping);
            return wrap("rename", { existing, replacements });
        },
        reverse: wrapNullArgs("reverse"),
        select(...exprs) {
            const predicate = (0, utils_1.selectionToExprList)(exprs, false);
            return wrap("select", { predicate });
        },
        shift: (periods) => wrap("shift", { periods }),
        shiftAndFill(optOrPeriods, fillValue) {
            if (typeof optOrPeriods === "number") {
                fillValue = (0, expr_1.exprToLitOrExpr)(fillValue)._expr;
                return wrap("shiftAndFill", { periods: optOrPeriods, fillValue });
            }
            else {
                fillValue = (0, expr_1.exprToLitOrExpr)(optOrPeriods.fillValue)._expr;
                const periods = optOrPeriods.periods;
                return wrap("shiftAndFill", { periods, fillValue });
            }
        },
        slice(opt, len) {
            if (opt?.offset !== undefined) {
                return wrap("slice", { offset: opt.offset, len: opt.length });
            }
            return wrap("slice", { offset: opt, len });
        },
        sort(arg, reverse = false) {
            if (arg?.by !== undefined) {
                return this.sort(arg.by, arg.reverse);
            }
            if (typeof arg === "string") {
                return wrap("sort", { by: arg, reverse });
            }
            else {
                reverse = [reverse].flat(3);
                const by = (0, utils_1.selectionToExprList)(arg, false);
                return wrap("sort_by_exprs", { by, reverse });
            }
        },
        std: wrapNullArgs("std"),
        sum: wrapNullArgs("sum"),
        var: wrapNullArgs("var"),
        tail: (length = 5) => wrap("tail", { length }),
        withColumn: (expr) => wrap("withColumn", { expr: expr._expr }),
        withColumns(...columns) {
            const exprs = (0, utils_1.selectionToExprList)(columns, false);
            return wrap("withColumns", { exprs });
        },
        withColumnRenamed: (existing, replacement) => wrap("withColumnRenamed", { existing, replacement }),
        withRowCount: (name = "row_nr") => wrap("withRowCount", { name }),
    };
};
exports.LazyDataFrame = LazyDataFrame;
