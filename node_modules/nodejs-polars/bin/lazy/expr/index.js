"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exprToLitOrExpr = exports.Expr = exports._Expr = void 0;
const dt = __importStar(require("./datetime"));
const lst = __importStar(require("./list"));
const str = __importStar(require("./string"));
const struct = __importStar(require("./struct"));
const polars_internal_1 = __importDefault(require("../../internals/polars_internal"));
const utils_1 = require("../../utils");
const series_1 = require("../../series");
const types_1 = require("util/types");
const _Expr = (_expr) => {
    const unwrap = (method, ...args) => {
        return _expr[method](...args);
    };
    const wrap = (method, ...args) => {
        return (0, exports._Expr)(unwrap(method, ...args));
    };
    const wrapExprArg = (method, lit = false) => (other) => {
        const expr = (0, exports.exprToLitOrExpr)(other, lit).inner();
        return wrap(method, expr);
    };
    const rolling = (method) => (opts, weights, minPeriods, center) => {
        const windowSize = opts?.["windowSize"] ?? (typeof opts === "number" ? opts : null);
        if (windowSize === null) {
            throw new Error("window size is required");
        }
        const callOpts = {
            windowSize: windowSize,
            weights: opts?.["weights"] ?? weights,
            minPeriods: opts?.["minPeriods"] ?? minPeriods ?? windowSize,
            center: opts?.["center"] ?? center ?? false,
        };
        return wrap(method, callOpts);
    };
    return {
        _expr,
        [Symbol.toStringTag]() {
            return "Expr";
        },
        [utils_1.INSPECT_SYMBOL]() {
            return _expr.toString();
        },
        serialize(format) {
            return _expr.serialize(format);
        },
        toString() {
            return _expr.toString();
        },
        toJSON(...args) {
            // this is passed by `JSON.stringify` when calling `toJSON()`
            if (args[0] === "") {
                return _expr.toJs();
            }
            return _expr.serialize("json").toString();
        },
        get str() {
            return str.ExprStringFunctions(_expr);
        },
        get lst() {
            return lst.ExprListFunctions(_expr);
        },
        get date() {
            return dt.ExprDateTimeFunctions(_expr);
        },
        get struct() {
            return struct.ExprStructFunctions(_expr);
        },
        abs() {
            return (0, exports._Expr)(_expr.abs());
        },
        aggGroups() {
            return (0, exports._Expr)(_expr.aggGroups());
        },
        alias(name) {
            return (0, exports._Expr)(_expr.alias(name));
        },
        inner() {
            return _expr;
        },
        and(other) {
            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();
            return (0, exports._Expr)(_expr.and(expr));
        },
        arccos() {
            return (0, exports._Expr)(_expr.arccos());
        },
        arccosh() {
            return (0, exports._Expr)(_expr.arccosh());
        },
        arcsin() {
            return (0, exports._Expr)(_expr.arcsin());
        },
        arcsinh() {
            return (0, exports._Expr)(_expr.arcsinh());
        },
        arctan() {
            return (0, exports._Expr)(_expr.arctan());
        },
        arctanh() {
            return (0, exports._Expr)(_expr.arctanh());
        },
        argMax() {
            return (0, exports._Expr)(_expr.argMax());
        },
        argMin() {
            return (0, exports._Expr)(_expr.argMin());
        },
        argSort(reverse = false, maintain_order) {
            reverse = reverse?.reverse ?? reverse;
            maintain_order = reverse?.maintain_order ?? maintain_order;
            return (0, exports._Expr)(_expr.argSort(reverse, false, false, maintain_order));
        },
        argUnique() {
            return (0, exports._Expr)(_expr.argUnique());
        },
        as(name) {
            return (0, exports._Expr)(_expr.alias(name));
        },
        backwardFill() {
            return (0, exports._Expr)(_expr.backwardFill());
        },
        cast(dtype, strict = false) {
            return (0, exports._Expr)(_expr.cast(dtype, strict));
        },
        ceil() {
            return (0, exports._Expr)(_expr.ceil());
        },
        clip(arg, max) {
            if (typeof arg === "number") {
                return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg)._expr, (0, exports.exprToLitOrExpr)(max)._expr));
            }
            return (0, exports._Expr)(_expr.clip((0, exports.exprToLitOrExpr)(arg.min)._expr, (0, exports.exprToLitOrExpr)(arg.max)._expr));
        },
        cos() {
            return (0, exports._Expr)(_expr.cos());
        },
        cosh() {
            return (0, exports._Expr)(_expr.cosh());
        },
        cot() {
            return (0, exports._Expr)(_expr.cot());
        },
        count() {
            return (0, exports._Expr)(_expr.count());
        },
        cumCount(reverse = false) {
            reverse = reverse?.reverse ?? reverse;
            return (0, exports._Expr)(_expr.cumCount(reverse?.reverse ?? reverse));
        },
        cumMax(reverse = false) {
            reverse = reverse?.reverse ?? reverse;
            return (0, exports._Expr)(_expr.cumMax(reverse));
        },
        cumMin(reverse = false) {
            reverse = reverse?.reverse ?? reverse;
            return (0, exports._Expr)(_expr.cumMin(reverse));
        },
        cumProd(reverse = false) {
            reverse = reverse?.reverse ?? reverse;
            return (0, exports._Expr)(_expr.cumProd(reverse));
        },
        cumSum(reverse = false) {
            reverse = reverse?.reverse ?? reverse;
            return (0, exports._Expr)(_expr.cumSum(reverse));
        },
        diff(n, nullBehavior = "ignore") {
            if (typeof n === "number") {
                return (0, exports._Expr)(_expr.diff(n, nullBehavior));
            }
            return (0, exports._Expr)(_expr.diff(n.n, n.nullBehavior));
        },
        dot(other) {
            const expr = (0, exports.exprToLitOrExpr)(other, false).inner();
            return (0, exports._Expr)(_expr.dot(expr));
        },
        ewmMean(opts, adjust, minPeriods, bias, ignoreNulls) {
            if (opts) {
                if (typeof opts === "number") {
                    return wrap("ewmMean", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);
                }
                return wrap("ewmMean", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);
            }
            return wrap("ewmMean", 0.5, true, 1, false, true);
        },
        ewmStd(opts, adjust, minPeriods, bias, ignoreNulls) {
            if (opts) {
                if (typeof opts === "number") {
                    return wrap("ewmStd", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);
                }
                return wrap("ewmStd", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);
            }
            return wrap("ewmStd", 0.5, true, 1, false, true);
        },
        ewmVar(opts, adjust, minPeriods, bias, ignoreNulls) {
            if (opts) {
                if (typeof opts === "number") {
                    return wrap("ewmVar", opts, adjust ?? true, minPeriods ?? 1, bias ?? false, ignoreNulls ?? true);
                }
                return wrap("ewmVar", opts.alpha ?? 0.5, opts.adjust ?? true, opts.minPeriods ?? 1, opts.bias ?? false, opts.ignoreNulls ?? true);
            }
            return wrap("ewmVar", 0.5, true, 1, false, true);
        },
        exclude(...columns) {
            return (0, exports._Expr)(_expr.exclude(columns.flat(2)));
        },
        explode() {
            return (0, exports._Expr)(_expr.explode());
        },
        exp() {
            return (0, exports._Expr)(_expr.exp());
        },
        extend(o, n) {
            if (n !== null && typeof n === "number") {
                return (0, exports._Expr)(_expr.extendConstant(o, n));
            }
            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));
        },
        extendConstant(o, n) {
            if (n !== null && typeof n === "number") {
                return (0, exports._Expr)(_expr.extendConstant(o, n));
            }
            return (0, exports._Expr)(_expr.extendConstant(o.value, o.n));
        },
        fillNan(other) {
            const expr = (0, exports.exprToLitOrExpr)(other, true).inner();
            return (0, exports._Expr)(_expr.fillNan(expr));
        },
        fillNull(fillValue) {
            if (["backward", "forward", "mean", "min", "max", "zero", "one"].includes(fillValue)) {
                return (0, exports._Expr)(_expr.fillNullWithStrategy(fillValue));
            }
            const expr = (0, exports.exprToLitOrExpr)(fillValue).inner();
            return (0, exports._Expr)(_expr.fillNull(expr));
        },
        filter(predicate) {
            const expr = (0, exports.exprToLitOrExpr)(predicate).inner();
            return (0, exports._Expr)(_expr.filter(expr));
        },
        first() {
            return (0, exports._Expr)(_expr.first());
        },
        flatten() {
            return (0, exports._Expr)(_expr.explode());
        },
        floor() {
            return (0, exports._Expr)(_expr.floor());
        },
        forwardFill() {
            return (0, exports._Expr)(_expr.forwardFill());
        },
        gather(indices) {
            if (Array.isArray(indices)) {
                indices = polars_internal_1.default.lit((0, series_1.Series)(indices).inner());
            }
            else {
                indices = indices.inner();
            }
            return wrap("gather", indices);
        },
        gatherEvery(n, offset = 0) {
            return (0, exports._Expr)(_expr.gatherEvery(n, offset));
        },
        hash(obj = 0, k1 = 1, k2 = 2, k3 = 3) {
            if (typeof obj === "number" || typeof obj === "bigint") {
                return wrap("hash", BigInt(obj), BigInt(k1), BigInt(k2), BigInt(k3));
            }
            const o = { k0: obj, k1: k1, k2: k2, k3: k3, ...obj };
            return wrap("hash", BigInt(o.k0), BigInt(o.k1), BigInt(o.k2), BigInt(o.k3));
        },
        head(length) {
            if (typeof length === "number") {
                return wrap("head", length);
            }
            return wrap("head", length.length);
        },
        interpolate(method = "linear") {
            return (0, exports._Expr)(_expr.interpolate(method));
        },
        isDuplicated() {
            return (0, exports._Expr)(_expr.isDuplicated());
        },
        isFinite() {
            return (0, exports._Expr)(_expr.isFinite());
        },
        isInfinite() {
            return (0, exports._Expr)(_expr.isInfinite());
        },
        isFirstDistinct() {
            return (0, exports._Expr)(_expr.isFirstDistinct());
        },
        isNan() {
            return (0, exports._Expr)(_expr.isNan());
        },
        isNotNan() {
            return (0, exports._Expr)(_expr.isNotNan());
        },
        isNotNull() {
            return (0, exports._Expr)(_expr.isNotNull());
        },
        isNull() {
            return (0, exports._Expr)(_expr.isNull());
        },
        isUnique() {
            return (0, exports._Expr)(_expr.isUnique());
        },
        isIn(other) {
            if (Array.isArray(other)) {
                other = polars_internal_1.default.lit((0, series_1.Series)(other).inner());
            }
            else {
                other = (0, exports.exprToLitOrExpr)(other, false).inner();
            }
            return wrap("isIn", other);
        },
        keepName() {
            return (0, exports._Expr)(_expr.keepName());
        },
        kurtosis(obj, bias = true) {
            const fisher = obj?.["fisher"] ?? (typeof obj === "boolean" ? obj : true);
            bias = obj?.["bias"] ?? bias;
            return (0, exports._Expr)(_expr.kurtosis(fisher, bias));
        },
        last() {
            return (0, exports._Expr)(_expr.last());
        },
        list() {
            return (0, exports._Expr)(_expr.list());
        },
        log1p() {
            console.log(_expr.log1p);
            return (0, exports._Expr)(_expr.log1p());
        },
        log(base) {
            return (0, exports._Expr)(_expr.log(base ?? Math.E));
        },
        lowerBound() {
            return (0, exports._Expr)(_expr.lowerBound());
        },
        peakMax() {
            return (0, exports._Expr)(_expr.peakMax());
        },
        peakMin() {
            return (0, exports._Expr)(_expr.peakMin());
        },
        max() {
            return (0, exports._Expr)(_expr.max());
        },
        mean() {
            return (0, exports._Expr)(_expr.mean());
        },
        median() {
            return (0, exports._Expr)(_expr.median());
        },
        min() {
            return (0, exports._Expr)(_expr.min());
        },
        mode() {
            return (0, exports._Expr)(_expr.mode());
        },
        not() {
            return (0, exports._Expr)(_expr.not());
        },
        nUnique() {
            return (0, exports._Expr)(_expr.nUnique());
        },
        or(other) {
            const expr = (0, exports.exprToLitOrExpr)(other).inner();
            return (0, exports._Expr)(_expr.or(expr));
        },
        over(...exprs) {
            const partitionBy = (0, utils_1.selectionToExprList)(exprs, false);
            return wrap("over", partitionBy);
        },
        pow(exponent) {
            return (0, exports._Expr)(_expr.pow(exponent?.exponent ?? exponent));
        },
        prefix(prefix) {
            return (0, exports._Expr)(_expr.prefix(prefix));
        },
        quantile(quantile, interpolation = "nearest") {
            if (exports.Expr.isExpr(quantile)) {
                quantile = quantile._expr;
            }
            else {
                quantile = polars_internal_1.default.lit(quantile);
            }
            return (0, exports._Expr)(_expr.quantile(quantile, interpolation));
        },
        rank(method = "average", reverse = false) {
            return (0, exports._Expr)(_expr.rank(method?.method ?? method, method?.reverse ?? reverse));
        },
        reinterpret(signed = true) {
            signed = signed?.signed ?? signed;
            return (0, exports._Expr)(_expr.reinterpret(signed));
        },
        repeatBy(expr) {
            const e = (0, exports.exprToLitOrExpr)(expr, false)._expr;
            return (0, exports._Expr)(_expr.repeatBy(e));
        },
        replace(old, newValue) {
            let oldIn = old;
            let newIn = newValue;
            if (old && typeof old === "object" && !Array.isArray(old)) {
                oldIn = Object.keys(old["old"]);
                newIn = Object.values(old["old"]);
            }
            return (0, exports._Expr)(_expr.replace((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr));
        },
        replaceStrict(old, newValue, defaultValue, returnDtype) {
            let oldIn = old;
            let newIn = newValue;
            let defIn = defaultValue;
            if (old && typeof old === "object" && !Array.isArray(old)) {
                oldIn = Object.keys(old["old"]);
                newIn = Object.values(old["old"]);
                defIn = old["default_"];
            }
            return (0, exports._Expr)(_expr.replaceStrict((0, exports.exprToLitOrExpr)(oldIn)._expr, (0, exports.exprToLitOrExpr)(newIn)._expr, defIn ? (0, exports.exprToLitOrExpr)(defIn)._expr : undefined, returnDtype));
        },
        reverse() {
            return (0, exports._Expr)(_expr.reverse());
        },
        rollingMax: rolling("rollingMax"),
        rollingMean: rolling("rollingMean"),
        rollingMin: rolling("rollingMin"),
        rollingSum: rolling("rollingSum"),
        rollingStd: rolling("rollingStd"),
        rollingVar: rolling("rollingVar"),
        rollingMedian: rolling("rollingMedian"),
        rollingQuantile(val, interpolation, windowSize, weights, minPeriods, center, by, closedWindow, warnIfUnsorted) {
            if (typeof val === "number") {
                return wrap("rollingQuantile", {
                    windowSize: `${windowSize}i`,
                    weights,
                    minPeriods,
                    center,
                });
            }
            windowSize =
                val?.["windowSize"] ?? (typeof val === "number" ? val : null);
            if (windowSize === null) {
                throw new Error("window size is required");
            }
            return wrap("rollingQuantile", val.quantile, val.interpolation ?? "nearest", windowSize, val?.["weights"] ?? weights ?? null, val?.["minPeriods"] ?? minPeriods ?? windowSize, val?.["center"] ?? center ?? false, val?.["by"] ?? by, closedWindow, val?.["warnIfUnsorted"] ?? warnIfUnsorted ?? true);
        },
        rollingSkew(val, bias = true) {
            if (typeof val === "number") {
                return wrap("rollingSkew", val, bias);
            }
            return wrap("rollingSkew", val.windowSize, val.bias ?? bias);
        },
        round(decimals) {
            return (0, exports._Expr)(_expr.round(decimals?.decimals ?? decimals));
        },
        sample(opts, frac, withReplacement = false, seed) {
            if (opts?.n !== undefined || opts?.frac !== undefined) {
                return this.sample(opts.n, opts.frac, opts.withReplacement, seed);
            }
            if (typeof opts === "number") {
                throw new Error("sample_n is not yet supported for expr");
            }
            if (typeof frac === "number") {
                return wrap("sampleFrac", frac, withReplacement, false, seed);
            }
            throw new TypeError("must specify either 'frac' or 'n'");
        },
        shift(periods) {
            return (0, exports._Expr)(_expr.shift((0, exports.exprToLitOrExpr)(periods)._expr));
        },
        shiftAndFill(optOrPeriods, fillValue) {
            if (typeof optOrPeriods === "number") {
                return wrap("shiftAndFill", optOrPeriods, fillValue);
            }
            return wrap("shiftAndFill", optOrPeriods.periods, optOrPeriods.fillValue);
        },
        skew(bias) {
            return wrap("skew", bias?.bias ?? bias ?? true);
        },
        sin() {
            return (0, exports._Expr)(_expr.sin());
        },
        sinh() {
            return (0, exports._Expr)(_expr.sinh());
        },
        slice(arg, len) {
            if (typeof arg === "number") {
                return wrap("slice", polars_internal_1.default.lit(arg), polars_internal_1.default.lit(len));
            }
            return wrap("slice", polars_internal_1.default.lit(arg.offset), polars_internal_1.default.lit(arg.length));
        },
        sort(reverse = false, nullsLast = false, maintain_order = false) {
            if (typeof reverse === "boolean") {
                return wrap("sortWith", reverse, nullsLast, false, maintain_order);
            }
            return wrap("sortWith", reverse?.reverse ?? false, reverse?.nullsLast ?? nullsLast, false, reverse?.maintain_order ?? maintain_order);
        },
        sortBy(arg, reverse = false) {
            if (arg?.by !== undefined) {
                return this.sortBy(arg.by, arg.reverse);
            }
            reverse = Array.isArray(reverse) ? reverse.flat() : [reverse];
            const by = (0, utils_1.selectionToExprList)(arg, false);
            return wrap("sortBy", by, reverse);
        },
        std() {
            return (0, exports._Expr)(_expr.std());
        },
        suffix(suffix) {
            return (0, exports._Expr)(_expr.suffix(suffix));
        },
        sum() {
            return (0, exports._Expr)(_expr.sum());
        },
        tail(length) {
            return (0, exports._Expr)(_expr.tail(length));
        },
        tan() {
            return (0, exports._Expr)(_expr.tan());
        },
        tanh() {
            return (0, exports._Expr)(_expr.tanh());
        },
        unique(opt) {
            if (opt || opt?.maintainOrder) {
                return wrap("uniqueStable");
            }
            return wrap("unique");
        },
        upperBound() {
            return (0, exports._Expr)(_expr.upperBound());
        },
        where(expr) {
            return this.filter(expr);
        },
        var() {
            return (0, exports._Expr)(_expr.var());
        },
        add: wrapExprArg("add"),
        sub: wrapExprArg("sub"),
        div: wrapExprArg("div"),
        mul: wrapExprArg("mul"),
        rem: wrapExprArg("rem"),
        plus: wrapExprArg("add"),
        minus: wrapExprArg("sub"),
        divideBy: wrapExprArg("div"),
        multiplyBy: wrapExprArg("mul"),
        modulo: wrapExprArg("rem"),
        eq: wrapExprArg("eq"),
        equals: wrapExprArg("eq"),
        gtEq: wrapExprArg("gtEq"),
        greaterThanEquals: wrapExprArg("gtEq"),
        gt: wrapExprArg("gt"),
        greaterThan: wrapExprArg("gt"),
        ltEq: wrapExprArg("ltEq"),
        lessThanEquals: wrapExprArg("ltEq"),
        lt: wrapExprArg("lt"),
        lessThan: wrapExprArg("lt"),
        neq: wrapExprArg("neq"),
        notEquals: wrapExprArg("neq"),
    };
};
exports._Expr = _Expr;
const isExpr = (anyVal) => {
    try {
        return anyVal?.[Symbol.toStringTag]?.() === "Expr";
    }
    catch (err) {
        return false;
    }
};
const deserialize = (buf, format) => {
    return (0, exports._Expr)(polars_internal_1.default.JsExpr.deserialize(buf, format));
};
exports.Expr = Object.assign(exports._Expr, {
    isExpr,
    deserialize,
});
const exprToLitOrExpr = (expr, stringToLit = true) => {
    if ((0, types_1.isRegExp)(expr)) {
        return (0, exports._Expr)(polars_internal_1.default.lit((0, utils_1.regexToString)(expr)));
    }
    if (typeof expr === "string" && !stringToLit) {
        return (0, exports._Expr)(polars_internal_1.default.col(expr));
    }
    if (exports.Expr.isExpr(expr)) {
        return expr;
    }
    if (series_1.Series.isSeries(expr)) {
        return (0, exports._Expr)(polars_internal_1.default.lit(expr._s));
    }
    return (0, exports._Expr)(polars_internal_1.default.lit(expr));
};
exports.exprToLitOrExpr = exprToLitOrExpr;
