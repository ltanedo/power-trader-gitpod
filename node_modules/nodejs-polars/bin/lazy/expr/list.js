"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExprListFunctions = void 0;
const expr_1 = require("../expr");
const series_1 = require("../../series");
const polars_internal_1 = __importDefault(require("../../internals/polars_internal"));
const functions_1 = require("../functions");
const ExprListFunctions = (_expr) => {
    const wrap = (method, ...args) => {
        return (0, expr_1._Expr)(_expr[method](...args));
    };
    return {
        argMax() {
            return wrap("listArgMax");
        },
        argMin() {
            return wrap("listArgMin");
        },
        concat(other) {
            if (Array.isArray(other) &&
                !(expr_1.Expr.isExpr(other[0]) ||
                    series_1.Series.isSeries(other[0]) ||
                    typeof other[0] === "string")) {
                return this.concat(polars_internal_1.default.Series([other]));
            }
            let otherList;
            if (!Array.isArray(other)) {
                otherList = [other];
            }
            else {
                otherList = [...other];
            }
            otherList = [(0, expr_1._Expr)(_expr), ...otherList];
            return (0, functions_1.concatList)(otherList);
        },
        contains(item) {
            return wrap("listContains", (0, expr_1.exprToLitOrExpr)(item)._expr);
        },
        diff(n = 1, nullBehavior = "ignore") {
            return wrap("listDiff", n, nullBehavior);
        },
        get(index) {
            if (expr_1.Expr.isExpr(index)) {
                return wrap("listGet", index._expr, true);
            }
            return wrap("listGet", polars_internal_1.default.lit(index), true);
        },
        head(n = 5) {
            return this.slice(0, n);
        },
        tail(n = 5) {
            return this.slice(-n, n);
        },
        eval(expr, parallel = true) {
            if (expr_1.Expr.isExpr(expr)) {
                return wrap("listEval", expr._expr, parallel);
            }
            return wrap("listEval", expr, parallel);
        },
        first() {
            return this.get(0);
        },
        join(options) {
            if (typeof options === "string") {
                options = { separator: options };
            }
            options = options ?? {};
            let separator = options?.separator ?? ",";
            const ignoreNulls = options?.ignoreNulls ?? false;
            if (!expr_1.Expr.isExpr(separator)) {
                separator = polars_internal_1.default.lit(separator);
            }
            return wrap("listJoin", separator, ignoreNulls);
        },
        last() {
            return this.get(-1);
        },
        lengths() {
            return wrap("listLengths");
        },
        max() {
            return wrap("listMax");
        },
        mean() {
            return wrap("listMean");
        },
        min() {
            return wrap("listMin");
        },
        reverse() {
            return wrap("listReverse");
        },
        shift(n) {
            return wrap("listShift", (0, expr_1.exprToLitOrExpr)(n)._expr);
        },
        slice(offset, length) {
            return wrap("listSlice", (0, expr_1.exprToLitOrExpr)(offset)._expr, (0, expr_1.exprToLitOrExpr)(length)._expr);
        },
        sort(reverse = false) {
            return typeof reverse === "boolean"
                ? wrap("listSort", reverse)
                : wrap("listSort", reverse.reverse);
        },
        sum() {
            return wrap("listSum");
        },
        unique() {
            return wrap("listUnique");
        },
    };
};
exports.ExprListFunctions = ExprListFunctions;
