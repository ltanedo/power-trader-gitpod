"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExprStringFunctions = void 0;
const datatypes_1 = require("../../datatypes");
const utils_1 = require("../../utils");
const expr_1 = require("../expr");
const functions_1 = require("../functions");
const ExprStringFunctions = (_expr) => {
    const wrap = (method, ...args) => {
        return (0, expr_1._Expr)(_expr[method](...args));
    };
    const handleDecode = (encoding, strict) => {
        switch (encoding) {
            case "hex":
                return wrap("strHexDecode", strict);
            case "base64":
                return wrap("strBase64Decode", strict);
            default:
                throw new RangeError("supported encodings are 'hex' and 'base64'");
        }
    };
    return {
        concat(delimiter, ignoreNulls = true) {
            return wrap("strConcat", delimiter, ignoreNulls);
        },
        contains(pat) {
            return wrap("strContains", (0, utils_1.regexToString)(pat), false);
        },
        decode(arg, strict = false) {
            if (typeof arg === "string") {
                return handleDecode(arg, strict);
            }
            return handleDecode(arg.encoding, arg.strict);
        },
        encode(encoding) {
            switch (encoding) {
                case "hex":
                    return wrap("strHexEncode");
                case "base64":
                    return wrap("strBase64Encode");
                default:
                    throw new RangeError("supported encodings are 'hex' and 'base64'");
            }
        },
        extract(pat, groupIndex) {
            return wrap("strExtract", (0, expr_1.exprToLitOrExpr)(pat, true)._expr, groupIndex);
        },
        jsonExtract(dtype, inferSchemaLength) {
            return wrap("strJsonDecode", dtype, inferSchemaLength);
        },
        jsonDecode(dtype, inferSchemaLength) {
            return wrap("strJsonDecode", dtype, inferSchemaLength);
        },
        jsonPathMatch(pat) {
            return wrap("strJsonPathMatch", [pat]);
        },
        lengths() {
            return wrap("strLengths");
        },
        lstrip() {
            return wrap("strLstrip");
        },
        replace(pat, val) {
            return wrap("strReplace", (0, utils_1.regexToString)(pat), val);
        },
        replaceAll(pat, val) {
            return wrap("strReplaceAll", (0, utils_1.regexToString)(pat), val);
        },
        rstrip() {
            return wrap("strRstrip");
        },
        padStart(length, fillChar) {
            return wrap("strPadStart", length, fillChar);
        },
        zFill(length) {
            if (!expr_1.Expr.isExpr(length)) {
                length = (0, functions_1.lit)(length)._expr;
            }
            return wrap("zfill", length);
        },
        padEnd(length, fillChar) {
            return wrap("strPadEnd", length, fillChar);
        },
        slice(start, length) {
            if (!expr_1.Expr.isExpr(start)) {
                start = (0, functions_1.lit)(start)._expr;
            }
            if (!expr_1.Expr.isExpr(length)) {
                length = (0, functions_1.lit)(length)._expr;
            }
            return wrap("strSlice", start, length);
        },
        split(by, options) {
            const inclusive = typeof options === "boolean" ? options : options?.inclusive;
            return wrap("strSplit", (0, expr_1.exprToLitOrExpr)(by)._expr, inclusive);
        },
        strip() {
            return wrap("strStrip");
        },
        strptime(dtype, format) {
            if (!(dtype instanceof datatypes_1.DataType)) {
                dtype = dtype();
            }
            if (dtype.equals(datatypes_1.DataType.Date)) {
                return wrap("strToDate", format, false, false, false);
            }
            if (dtype.equals(datatypes_1.DataType.Datetime("ms"))) {
                return wrap("strToDatetime", format, undefined, undefined, false, false, false);
            }
            throw new Error(`only "DataType.Date" and "DataType.Datetime" are supported`);
        },
        toLowerCase() {
            return wrap("strToLowercase");
        },
        toUpperCase() {
            return wrap("strToUppercase");
        },
    };
};
exports.ExprStringFunctions = ExprStringFunctions;
