"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.exprToLitOrExpr = exports.Expr = void 0;
const datatypes_1 = require("../datatypes");
const polars_internal_1 = __importDefault(require("../internals/polars_internal"));
const lazy_functions_1 = require("./lazy_functions");
const utils_1 = require("../utils");
const series_1 = require("../series");
const inspect = Symbol.for("nodejs.util.inspect.custom");
const ExprListFunctions = (_expr) => {
    const wrap = (method, args) => {
        return (0, exports.Expr)(polars_internal_1.default.expr.lst[method]({ _expr, ...args }));
    };
    return {
        get(index) {
            return wrap("get", { index });
        },
        first() {
            return wrap("get", { index: 0 });
        },
        last() {
            return wrap("get", { index: -1 });
        },
        lengths() {
            return wrap("lengths");
        },
        max() {
            return wrap("max");
        },
        mean() {
            return wrap("mean");
        },
        min() {
            return wrap("min");
        },
        reverse() {
            return wrap("reverse");
        },
        sort(reverse = false) {
            return typeof reverse === "boolean" ?
                wrap("sort", { reverse }) :
                wrap("sort", reverse);
        },
        sum() {
            return wrap("sum");
        },
        unique() {
            return wrap("unique");
        },
    };
};
const ExprDateTimeFunctions = (_expr) => {
    const wrap = (method, args) => {
        return (0, exports.Expr)(polars_internal_1.default.expr.date[method]({ _expr, ...args }));
    };
    const wrapNullArgs = (method) => () => wrap(method);
    return {
        day: wrapNullArgs("day"),
        hour: wrapNullArgs("hour"),
        minute: wrapNullArgs("minute"),
        month: wrapNullArgs("month"),
        nanosecond: wrapNullArgs("nanosecond"),
        ordinalDay: wrapNullArgs("ordinalDay"),
        second: wrapNullArgs("second"),
        strftime: (fmt) => wrap("strftime", { fmt }),
        timestamp: wrapNullArgs("timestamp"),
        week: wrapNullArgs("week"),
        weekday: wrapNullArgs("weekday"),
        year: wrapNullArgs("year"),
    };
};
const ExprStringFunctions = (_expr) => {
    const wrap = (method, args) => {
        return (0, exports.Expr)(polars_internal_1.default.expr.str[method]({ _expr, ...args }));
    };
    return {
        concat(delimiter) {
            return wrap("concat", { delimiter });
        },
        contains(pat) {
            return wrap("contains", { pat: (0, utils_1.regexToString)(pat) });
        },
        extract(pat, groupIndex) {
            return wrap("extract", { pat: (0, utils_1.regexToString)(pat), groupIndex });
        },
        jsonPathMatch(pat) {
            return wrap("jsonPathMatch", { pat });
        },
        lengths() {
            return wrap("lengths");
        },
        lstrip() {
            return wrap("replace", { pat: /^\s*/.source, val: "" });
        },
        replace(pat, val) {
            return wrap("replace", { pat: (0, utils_1.regexToString)(pat), val });
        },
        replaceAll(pat, val) {
            return wrap("replaceAll", { pat: (0, utils_1.regexToString)(pat), val });
        },
        rstrip() {
            return wrap("replace", { pat: /[ \t]+$/.source, val: "" });
        },
        slice(start, length) {
            return wrap("slice", { start, length });
        },
        strftime(dtype, fmt) {
            if (dtype === datatypes_1.DataType.Date) {
                return wrap("parseDate", { fmt });
            }
            else if (dtype === datatypes_1.DataType.Datetime) {
                return wrap("parseDateTime", { fmt });
            }
            else {
                throw new Error(`only "DataType.Date" and "DataType.Datetime" are supported`);
            }
        },
        toLowerCase() {
            return wrap("toLowerCase");
        },
        toUpperCase() {
            return wrap("toUpperCase");
        },
    };
};
const Expr = (_expr) => {
    const wrap = (method, args) => {
        return (0, exports.Expr)(polars_internal_1.default.expr[method]({ _expr, ...args }));
    };
    const wrapNullArgs = (method) => () => wrap(method);
    const wrapExprArg = (method, lit = false) => (other) => {
        const expr = (0, exports.exprToLitOrExpr)(other, lit)._expr;
        return wrap(method, { other: expr });
    };
    const wrapUnary = (method, key) => (val) => wrap(method, { [key]: val?.[key] ?? val });
    const wrapUnaryWithDefault = (method, key, otherwise) => (val = otherwise) => wrap(method, { [key]: val?.[key] ?? val });
    const wrapBinary = (method, key0, key1) => (val0, val1) => {
        if (val0[key0] !== undefined) {
            return wrap(method, val0);
        }
        return wrap(method, {
            [key0]: val0,
            [key1]: val1
        });
    };
    const wrapUnaryNumber = (method, key) => {
        const f = (val) => {
            if (typeof val === "number") {
                return f({ [key]: val });
            }
            return wrap(method, val);
        };
        return f;
    };
    const exclude = (column, ...columns) => {
        return wrap("exclude", { columns: [column, ...columns] });
    };
    const fillNull = (fillValue) => {
        if (["backward", "forward", "mean", "min", "max", "zero", "one"].includes(fillValue)) {
            return wrap("fillNullWithStrategy", { strategy: fillValue });
        }
        const expr = (0, exports.exprToLitOrExpr)(fillValue)._expr;
        return wrap("fillNull", { other: expr });
    };
    const isIn = (other) => {
        if (Array.isArray(other)) {
            other = (0, lazy_functions_1.lit)((0, series_1.Series)(other));
        }
        else {
            other = (0, exports.exprToLitOrExpr)(other, false);
        }
        return wrap("isIn", { other: other._expr });
    };
    const kurtosis = (obj, bias = true) => {
        return wrap("kurtosis", {
            fisher: obj?.["fisher"] ?? (typeof obj === "boolean" ? obj : true),
            bias: obj?.["bias"] ?? bias,
        });
    };
    const hash = (obj = 0, k1 = 1, k2 = 2, k3 = 3) => {
        if (typeof obj === "number" || typeof obj === "bigint") {
            return wrap("hash", {
                k0: obj,
                k1: k1,
                k2: k2,
                k3: k3
            });
        }
        return wrap("hash", obj);
    };
    const over = (...exprs) => {
        const partitionBy = (0, utils_1.selectionToExprList)(exprs, false);
        return wrap("over", { partitionBy });
    };
    const shiftAndFill = (opt, fillValue) => {
        if (opt?.periods !== undefined) {
            return shiftAndFill(opt.periods, opt.fillValue);
        }
        fillValue = (0, exports.exprToLitOrExpr)(fillValue, true)._expr;
        return wrap("shiftAndFill", { periods: opt, fillValue });
    };
    const rollingSkew = (val, bias = true) => {
        if (typeof val === "number") {
            return wrap("rollingSkew", { windowSize: val, bias });
        }
        return rollingSkew(val.windowSize, val.bias);
    };
    const sort = (reverse = false, nullsLast = false) => {
        if (typeof reverse === "boolean") {
            return wrap("sortWith", { reverse, nullsLast });
        }
        return wrap("sortWith", reverse);
    };
    const take = (indices) => {
        if (Array.isArray(indices)) {
            indices = (0, lazy_functions_1.lit)((0, series_1.Series)(indices));
        }
        return wrap("take", { other: indices._expr });
    };
    return {
        _expr,
        [inspect]() { return polars_internal_1.default.expr.as_str({ _expr }); },
        get str() { return ExprStringFunctions(_expr); },
        get lst() { return ExprListFunctions(_expr); },
        get date() { return ExprDateTimeFunctions(_expr); },
        abs: wrapNullArgs("abs"),
        aggGroups: wrapNullArgs("aggGroups"),
        alias: wrapUnary("alias", "name"),
        and: wrapExprArg("and"),
        argMax: wrapNullArgs("argMax"),
        argMin: wrapNullArgs("argMin"),
        argSort: wrapUnaryWithDefault("argSort", "reverse", false),
        argUnique: wrapNullArgs("argUnique"),
        as: wrapUnary("alias", "name"),
        backwardFill: wrapNullArgs("backwardFill"),
        cast: (dtype, strict = false) => wrap("cast", { dtype, strict }),
        count: wrapNullArgs("count"),
        cumCount: wrapUnaryWithDefault("cumCount", "reverse", false),
        cumMax: wrapUnaryWithDefault("cumMax", "reverse", false),
        cumMin: wrapUnaryWithDefault("cumMin", "reverse", false),
        cumProd: wrapUnaryWithDefault("cumProd", "reverse", false),
        cumSum: wrapUnaryWithDefault("cumSum", "reverse", false),
        diff: wrapBinary("diff", "n", "nullBehavior"),
        dot: wrapExprArg("dot"),
        eq: wrapExprArg("eq"),
        exclude,
        explode: wrapNullArgs("explode"),
        fillNan: wrapExprArg("fillNan", true),
        fillNull,
        fillNullWithStrategy: wrapUnary("fillNullWithStrategy", "strategy"),
        filter: wrapExprArg("filter"),
        first: wrapNullArgs("first"),
        flatten: wrapNullArgs("explode"),
        floor: wrapNullArgs("floor"),
        forwardFill: wrapNullArgs("forwardFill"),
        gt: wrapExprArg("gt"),
        gtEq: wrapExprArg("gtEq"),
        hash,
        head: wrapUnaryNumber("head", "length"),
        interpolate: wrapNullArgs("interpolate"),
        isDuplicated: wrapNullArgs("isDuplicated"),
        isFinite: wrapNullArgs("isFinite"),
        isFirst: wrapNullArgs("isFirst"),
        isIn,
        isInfinite: wrapNullArgs("isInfinite"),
        isNan: wrapNullArgs("isNan"),
        isNotNan: wrapNullArgs("isNotNan"),
        isNotNull: wrapNullArgs("isNotNull"),
        isNull: wrapNullArgs("isNull"),
        isUnique: wrapNullArgs("isUnique"),
        keepName: wrapNullArgs("keepName"),
        kurtosis,
        last: wrapNullArgs("last"),
        list: wrapNullArgs("list"),
        lowerBound: wrapNullArgs("lowerBound"),
        lt: wrapExprArg("lt"),
        ltEq: wrapExprArg("ltEq"),
        max: wrapNullArgs("max"),
        mean: wrapNullArgs("mean"),
        median: wrapNullArgs("median"),
        min: wrapNullArgs("min"),
        mode: wrapNullArgs("mode"),
        neq: wrapExprArg("neq"),
        not: wrapNullArgs("not"),
        nUnique: wrapNullArgs("nUnique"),
        or: wrapExprArg("or"),
        over,
        pow: wrapUnary("pow", "exponent"),
        prefix: wrapUnary("prefix", "prefix"),
        quantile: wrapUnary("quantile", "quantile"),
        rank: wrapUnary("rank", "method"),
        reinterpret: wrapUnaryWithDefault("reinterpret", "signed", true),
        repeatBy: wrapExprArg("repeatBy"),
        reshape: wrapUnary("reshape", "dims"),
        reverse: wrapNullArgs("reverse"),
        rollingMedian: wrapUnary("rollingMedian", "windowSize"),
        rollingQuantile: wrapBinary("rollingQuantile", "windowSize", "quantile"),
        rollingSkew,
        round: wrapUnaryNumber("round", "decimals"),
        shift: wrapUnary("shift", "periods"),
        shiftAndFill,
        skew: wrapUnaryWithDefault("skew", "bias", true),
        slice: wrapBinary("slice", "offset", "length"),
        sort,
        std: wrapNullArgs("std"),
        suffix: wrapUnary("suffix", "suffix"),
        sum: wrapNullArgs("sum"),
        tail: wrapUnaryNumber("tail", "length"),
        take,
        takeEvery: wrapUnary("takeEvery", "n"),
        unique: wrapNullArgs("unique"),
        upperBound: wrapNullArgs("upperBound"),
        where: wrapExprArg("filter"),
        var: wrapNullArgs("var")
    };
};
exports.Expr = Expr;
const exprToLitOrExpr = (expr, stringToLit = true) => {
    if (typeof expr === "string" && !stringToLit) {
        return (0, lazy_functions_1.col)(expr);
    }
    else if ((0, utils_1.isExpr)(expr)) {
        return expr;
    }
    else if (Array.isArray(expr)) {
        return expr.map(e => (0, exports.exprToLitOrExpr)(e, stringToLit));
    }
    else {
        return (0, lazy_functions_1.lit)(expr);
    }
};
exports.exprToLitOrExpr = exprToLitOrExpr;
