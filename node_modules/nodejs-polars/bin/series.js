"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Series = exports.seriesWrapper = void 0;
const polars_internal_1 = __importDefault(require("./internals/polars_internal"));
const construction_1 = require("./internals/construction");
const datatypes_1 = require("./datatypes");
const dataframe_1 = require("./dataframe");
const string_1 = require("./series/string");
const list_1 = require("./series/list");
const datetime_1 = require("./series/datetime");
const error_1 = require("./error");
const utils_1 = require("./utils");
const lazy_functions_1 = require("./lazy/lazy_functions");
const inspect = Symbol.for("nodejs.util.inspect.custom");
const seriesWrapper = (_s) => {
    const unwrap = (method, args, _series = _s) => {
        return polars_internal_1.default.series[method]({ _series, ...args });
    };
    const wrap = (method, args, _series = _s) => {
        return (0, exports.seriesWrapper)(unwrap(method, args, _series));
    };
    const noArgWrap = (method) => () => wrap(method);
    const noArgUnwrap = (method) => () => unwrap(method);
    const dtypeAccessor = (fn) => (method, args, _series = _s) => {
        const dtype = unwrap("dtype");
        if (args.field?._series) {
            return fn(method, { [args.key]: args.field._series }, _series);
        }
        else {
            const dt = datatypes_1.DTYPE_TO_FFINAME[datatypes_1.DataType[dtype]];
            const internalMethod = `${method}_${dt}`;
            if (datatypes_1.DataType[dtype] === datatypes_1.DataType.List) {
                return (0, exports.seriesWrapper)(fn(internalMethod, { [args.key]: args.field }, _series));
            }
            return fn(internalMethod, { [args.key]: args.field }, _series);
        }
    };
    const inPlaceOptional = (method) => (obj) => {
        if (obj === true || obj?.["inPlace"] === true) {
            unwrap(method, { inPlace: true });
        }
        else {
            return wrap(method);
        }
    };
    const rolling = (method) => (opts, weights, minPeriods, center) => {
        const windowSize = opts?.["windowSize"] ?? (typeof opts === "number" ? opts : null);
        if (windowSize === null) {
            throw new Error("window size is required");
        }
        const callOpts = {
            window_size: opts?.["windowSize"] ?? (typeof opts === "number" ? opts : null),
            weights: opts?.["weights"] ?? weights,
            min_periods: opts?.["minPeriods"] ?? minPeriods ?? windowSize,
            center: opts?.["center"] ?? center ?? false,
        };
        return wrap(method, callOpts);
    };
    const seriesObject = {
        _series: _s,
        [inspect]() {
            return unwrap("get_fmt");
        },
        *[Symbol.iterator]() {
            let start = 0;
            let len = unwrap("len");
            while (start < len) {
                const v = this.get(start);
                start++;
                yield v;
            }
        },
        toString() {
            return unwrap("get_fmt");
        },
        get [Symbol.toStringTag]() {
            return "Series";
        },
        get dtype() {
            return unwrap("dtype");
        },
        get name() {
            return unwrap("name");
        },
        get length() {
            return unwrap("len");
        },
        get str() {
            return (0, string_1.StringFunctions)(_s);
        },
        get lst() {
            return (0, list_1.ListFunctions)(_s);
        },
        get date() {
            return (0, datetime_1.DateTimeFunctions)(_s);
        },
        abs: noArgWrap("abs"),
        add(field) {
            return dtypeAccessor(wrap)("add", { field, key: "other" });
        },
        alias(name) {
            const s = this.clone();
            unwrap("rename", { name }, s._series);
            return s;
        },
        append(other) {
            return wrap("append", { other: other._series });
        },
        apply(func) {
            return wrap("map", { func });
        },
        argMax: noArgUnwrap("arg_max"),
        argMin: noArgUnwrap("arg_min"),
        argSort(reverse = false) {
            return typeof reverse === "boolean" ?
                wrap("argsort", { reverse }) :
                wrap("argsort", reverse);
        },
        argTrue: noArgWrap("arg_true"),
        argUnique: noArgWrap("arg_unique"),
        as(name) {
            return this.alias(name);
        },
        bitand(other) {
            return wrap("bitand", { other: other._series });
        },
        bitor(other) {
            return wrap("bitor", { other: other._series });
        },
        bitxor(other) {
            return wrap("bitxor", { other: other._series });
        },
        cast(dtype, strict = false) {
            return typeof strict === "boolean" ?
                wrap("cast", { dtype, strict }) :
                wrap("cast", { dtype, ...strict });
        },
        chunkLengths: noArgUnwrap("chunk_lengths"),
        clone() {
            return wrap("clone");
        },
        concat(other) {
            const s = this.clone();
            unwrap("append", { other: other._series }, s._series);
            return s;
        },
        cumMax(reverse = false) {
            return typeof reverse === "boolean" ?
                wrap("cummax", { reverse }) :
                wrap("cummax", reverse);
        },
        cumMin(reverse = false) {
            return typeof reverse === "boolean" ?
                wrap("cummin", { reverse }) :
                wrap("cummin", reverse);
        },
        cumProd(reverse = false) {
            return typeof reverse === "boolean" ?
                wrap("cumprod", { reverse }) :
                wrap("cumprod", reverse);
        },
        cumSum(reverse = false) {
            return typeof reverse === "boolean" ?
                wrap("cumsum", { reverse }) :
                wrap("cumsum", reverse);
        },
        describe() {
            let s = (0, exports.seriesWrapper)(_s);
            let stats = {};
            if (!this.length) {
                throw new RangeError("Series must contain at least one value");
            }
            if (this.isNumeric()) {
                s = s.cast(datatypes_1.DataType.Float64);
                stats = {
                    "min": s.min(),
                    "max": s.max(),
                    "null_count": s.nullCount(),
                    "mean": s.mean(),
                    "count": s.len(),
                };
            }
            else if (s.isBoolean()) {
                stats = {
                    "sum": s.sum(),
                    "null_count": s.nullCount(),
                    "count": s.len(),
                };
            }
            else if (s.isUtf8()) {
                stats = {
                    "unique": s.nUnique(),
                    "null_count": s.nullCount(),
                    "count": s.len(),
                };
            }
            else if (s.isDateTime()) {
                throw (0, error_1.todo)();
            }
            else {
                throw new error_1.InvalidOperationError("describe", s.dtype);
            }
            return (0, dataframe_1.DataFrame)({
                "statistic": Object.keys(stats),
                "value": Object.values(stats)
            });
        },
        diff(n = 1, null_behavior = "ignore") {
            return typeof n === "number" ?
                wrap("diff", { n, null_behavior }) :
                wrap("diff", {
                    n: n?.n ?? 1,
                    null_behavior: n.nullBehavior ?? null_behavior
                });
        },
        div(field) {
            return dtypeAccessor(wrap)("div", { field, key: "other" });
        },
        divide(field) {
            return this.div(field);
        },
        dot(other) {
            return unwrap("dot", { other: other._series });
        },
        dropNulls: noArgWrap("drop_nulls"),
        eq(field) {
            return dtypeAccessor(wrap)("eq", { field, key: "rhs" });
        },
        equals(field) {
            return this.eq(field);
        },
        explode: noArgWrap("explode"),
        fillNull(strategy) {
            return typeof strategy === "string" ?
                wrap("fill_null", { strategy }) :
                wrap("fill_null", strategy);
        },
        filter(predicate) {
            return (0, utils_1.isSeries)(predicate) ?
                wrap("filter", { filter: predicate._series }) :
                wrap("filter", { filter: predicate.predicate._series });
        },
        floor: noArgWrap("floor"),
        get(field) {
            return dtypeAccessor(unwrap)("get", { field, key: "index" });
        },
        getIndex(idx) {
            return unwrap("get_idx", { idx });
        },
        gt(field) {
            return dtypeAccessor(wrap)("gt", { field, key: "rhs" });
        },
        gt_eq(field) {
            return dtypeAccessor(wrap)("gt_eq", { field, key: "rhs" });
        },
        greaterThan(field) {
            return this.gt(field);
        },
        greaterThanEquals(field) {
            return this.gt_eq(field);
        },
        hash(obj = 0, k1 = 1, k2 = 2, k3 = 3) {
            if (typeof obj === "number" || typeof obj === "bigint") {
                return wrap("hash", { k0: obj, k1: k1, k2: k2, k3: k3 });
            }
            return wrap("hash", { k0: 0, k1, k2, k3, ...obj });
        },
        hasValidity: noArgUnwrap("has_validity"),
        head(length = 5) {
            return wrap("head", { length });
        },
        inner() {
            return _s;
        },
        interpolate: noArgWrap("interpolate"),
        isBoolean() {
            const dtype = unwrap("dtype");
            return datatypes_1.DataType[dtype] === datatypes_1.DataType.Bool;
        },
        isDateTime() {
            const dtype = unwrap("dtype");
            return [datatypes_1.DataType.Date, datatypes_1.DataType.Datetime].includes(datatypes_1.DataType[dtype]);
        },
        isDuplicated: noArgWrap("is_duplicated"),
        isFinite() {
            const dtype = unwrap("dtype");
            if (![datatypes_1.DataType.Float32, datatypes_1.DataType.Float64].includes(datatypes_1.DataType[dtype])) {
                throw new error_1.InvalidOperationError("isFinite", dtype);
            }
            else {
                return wrap("is_finite");
            }
        },
        isFirst: noArgWrap("is_first"),
        isFloat() {
            const dtype = this.dtype;
            return [datatypes_1.DataType.Float32, datatypes_1.DataType.Float64].includes(datatypes_1.DataType[dtype]);
        },
        isIn(other) {
            return (0, utils_1.isSeries)(other) ?
                wrap("is_in", { other: other._series }) :
                wrap("is_in", { other: Series(other)._series });
        },
        isInfinite() {
            const dtype = unwrap("dtype");
            if (![datatypes_1.DataType.Float32, datatypes_1.DataType.Float64].includes(datatypes_1.DataType[dtype])) {
                throw new error_1.InvalidOperationError("isInfinite", dtype);
            }
            else {
                return wrap("is_infinite");
            }
        },
        isNotNull: noArgWrap("is_not_null"),
        isNull: noArgWrap("is_null"),
        isNumeric() {
            const dtype = unwrap("dtype");
            const numericTypes = [
                datatypes_1.DataType.Int8,
                datatypes_1.DataType.Int16,
                datatypes_1.DataType.Int32,
                datatypes_1.DataType.Int64,
                datatypes_1.DataType.UInt8,
                datatypes_1.DataType.UInt16,
                datatypes_1.DataType.UInt32,
                datatypes_1.DataType.UInt64,
                datatypes_1.DataType.Float32,
                datatypes_1.DataType.Float64
            ];
            return numericTypes.includes(datatypes_1.DataType[dtype]);
        },
        isUnique: noArgWrap("is_unique"),
        isUtf8() {
            const dtype = unwrap("dtype");
            return datatypes_1.DataType[dtype] === datatypes_1.DataType.Utf8;
        },
        kurtosis(fisher = true, bias = true) {
            if (typeof fisher === "boolean") {
                return unwrap("kurtosis", { fisher, bias });
            }
            return unwrap("kurtosis", {
                fisher: true,
                bias,
                ...fisher
            });
        },
        len: noArgUnwrap("len"),
        lessThan: (field) => dtypeAccessor(wrap)("lt", { field, key: "rhs" }),
        lessThanEquals: (field) => dtypeAccessor(wrap)("lt_eq", { field, key: "rhs" }),
        limit: (n = 10) => wrap("limit", { num_elements: n }),
        lt_eq: (field) => dtypeAccessor(wrap)("lt_eq", { field, key: "rhs" }),
        lt: (field) => dtypeAccessor(wrap)("lt", { field, key: "rhs" }),
        map: (func) => wrap("map", { func }),
        max: noArgUnwrap("max"),
        mean: noArgUnwrap("mean"),
        median: noArgUnwrap("median"),
        min: noArgUnwrap("min"),
        minus: (field) => dtypeAccessor(wrap)("sub", { field, key: "other" }),
        mode: noArgWrap("mode"),
        mul: (field) => dtypeAccessor(wrap)("mul", { field, key: "other" }),
        nChunks: noArgUnwrap("n_chunks"),
        neq: (field) => dtypeAccessor(wrap)("neq", { field, key: "rhs" }),
        notEquals: (field) => dtypeAccessor(wrap)("neq", { field, key: "rhs" }),
        nullCount: noArgUnwrap("null_count"),
        nUnique: noArgUnwrap("n_unique"),
        peakMax: noArgWrap("peak_max"),
        peakMin: noArgWrap("peak_min"),
        plus: (field) => dtypeAccessor(wrap)("add", { field, key: "other" }),
        quantile: (quantile) => unwrap("quantile", { quantile }),
        rank: (method = "average") => wrap("rank", { method }),
        rechunk: inPlaceOptional("rechunk"),
        reinterpret(signed = true) {
            const dtype = unwrap("dtype");
            if ([datatypes_1.DataType.UInt64, datatypes_1.DataType.Int64].includes(datatypes_1.DataType[dtype])) {
                return wrap("reinterpret", { signed });
            }
            else {
                throw new error_1.InvalidOperationError("reinterpret", dtype);
            }
        },
        rem: (field) => dtypeAccessor(wrap)("rem", { field, key: "other" }),
        remainder: (field) => dtypeAccessor(wrap)("rem", { field, key: "other" }),
        rename(obj, inPlace = false) {
            if (obj?.inPlace ?? inPlace) {
                unwrap("rename", { name: obj?.name ?? obj });
            }
            else {
                return this.alias(obj?.name ?? obj);
            }
        },
        rollingMax: rolling("rolling_max"),
        rollingMean: rolling("rolling_mean"),
        rollingMin: rolling("rolling_min"),
        rollingSum: rolling("rolling_sum"),
        rollingVar: rolling("rolling_var"),
        round(opt) {
            if (this.isNumeric()) {
                if (typeof opt === "number") {
                    return wrap("round", { decimals: opt });
                }
                else {
                    return wrap("round", opt);
                }
            }
            else {
                throw new error_1.InvalidOperationError("round", this.dtype);
            }
        },
        sample(opts, frac, withReplacement = false) {
            if (opts?.n !== undefined || opts?.frac !== undefined) {
                return this.sample(opts.n, opts.frac, opts.withReplacement);
            }
            if (typeof opts === "number") {
                return wrap("sample_n", {
                    n: opts,
                    withReplacement
                });
            }
            if (typeof frac === "number") {
                return wrap("sample_frac", {
                    frac,
                    withReplacement,
                });
            }
            else {
                throw new TypeError("must specify either 'frac' or 'n'");
            }
        },
        seriesEqual(other, opt = true) {
            return unwrap("series_equal", {
                other: other._series,
                null_equal: opt?.nullEqual ?? opt
            });
        },
        set(filter, value) {
            const dtype = this.dtype;
            const dt = datatypes_1.DTYPE_TO_FFINAME[datatypes_1.DataType[dtype]];
            if (!dt) {
                throw (0, error_1.todo)();
            }
            return wrap(`set_with_mask_${dt}`, { filter: filter._series, value });
        },
        setAtIdx(indices, value) {
            const dtype = this.dtype;
            const dt = datatypes_1.DTYPE_TO_FFINAME[datatypes_1.DataType[dtype]];
            if (!dt) {
                throw (0, error_1.todo)();
            }
            indices = (0, utils_1.isSeries)(indices) ? indices.cast(datatypes_1.DataType.UInt32).toArray() : indices;
            unwrap(`set_at_idx_${dt}`, { indices, value });
            return this;
        },
        shift(opt = 1) {
            if (typeof opt === "number") {
                return wrap("shift", { periods: opt });
            }
            return wrap("shift", opt);
        },
        shiftAndFill(opt, fillValue) {
            return this
                .toFrame()
                .select((0, lazy_functions_1.col)(this.name).shiftAndFill(opt, fillValue))
                .getColumn(this.name);
        },
        shrinkToFit: inPlaceOptional("shrink_to_fit"),
        skew(opt = true) {
            if (typeof opt === "boolean") {
                return unwrap("skew", { bias: opt });
            }
            return unwrap("skew", opt);
        },
        slice(opts, length) {
            if (typeof opts === "number") {
                return wrap("slice", { offset: opts, length });
            }
            return wrap("slice", opts);
        },
        sort(opt = false) {
            if (typeof opt === "boolean") {
                return wrap("sort", { reverse: opt });
            }
            return wrap("sort", opt);
        },
        sub: (field) => dtypeAccessor(wrap)("sub", { field, key: "other" }),
        sum: noArgUnwrap("sum"),
        tail: (length = 5) => wrap("tail", { length }),
        take: (indices) => wrap("take", { indices }),
        takeEvery: (n) => wrap("take_every", { n }),
        times: (field) => dtypeAccessor(wrap)("mul", { field, key: "other" }),
        toArray() {
            const series = (0, exports.seriesWrapper)(_s);
            const dtype = series.dtype;
            if (datatypes_1.DataType[dtype] === datatypes_1.DataType.List) {
                return [...series].map(s => s.toArray());
            }
            return Array.from(series);
        },
        toFrame() {
            return (0, dataframe_1.dfWrapper)(polars_internal_1.default.df.read_columns({ columns: [_s] }));
        },
        toJS: noArgUnwrap("to_js"),
        unique: noArgWrap("unique"),
        valueCounts() {
            return (0, dataframe_1.dfWrapper)(unwrap("value_counts"));
        },
        zipWith(mask, other) {
            return wrap("zip_with", { mask: mask._series, other: other._series });
        },
    };
    return new Proxy(seriesObject, {
        get: function (target, prop, receiver) {
            if (typeof prop !== "symbol" && !Number.isNaN(Number(prop))) {
                return target.get(Number(prop));
            }
            else {
                return Reflect.get(target, prop, receiver);
            }
        },
    });
};
exports.seriesWrapper = seriesWrapper;
function Series(arg0, arg1, dtype, strict) {
    if (typeof arg0 === "string") {
        const _s = (0, construction_1.arrayToJsSeries)(arg0, arg1, dtype, strict);
        return (0, exports.seriesWrapper)(_s);
    }
    return Series("", arg0);
}
exports.Series = Series;
