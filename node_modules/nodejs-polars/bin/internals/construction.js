"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayToJsDataFrame = exports.arrayToJsSeries = exports.jsTypeToPolarsType = void 0;
const polars_internal_1 = __importDefault(require("./polars_internal"));
const datatypes_1 = require("../datatypes");
const types_1 = require("util/types");
const series_1 = require("../series");
const jsTypeToPolarsType = (value) => {
    if (Array.isArray(value)) {
        return (0, exports.jsTypeToPolarsType)(value[0]);
    }
    if ((0, types_1.isTypedArray)(value)) {
        switch (value.constructor.name) {
            case Int8Array.name:
                return datatypes_1.DataType.Int8;
            case Int16Array.name:
                return datatypes_1.DataType.Int16;
            case Int32Array.name:
                return datatypes_1.DataType.Int32;
            case BigInt64Array.name:
                return datatypes_1.DataType.Int64;
            case Uint8Array.name:
                return datatypes_1.DataType.UInt8;
            case Uint16Array.name:
                return datatypes_1.DataType.UInt16;
            case Uint32Array.name:
                return datatypes_1.DataType.UInt32;
            case BigUint64Array.name:
                return datatypes_1.DataType.UInt64;
            case Float32Array.name:
                return datatypes_1.DataType.Float32;
            case Float64Array.name:
                return datatypes_1.DataType.Float64;
            default:
                throw new Error(`unknown  typed array type: ${value.constructor.name}`);
        }
    }
    if (value instanceof Date) {
        return datatypes_1.DataType.Datetime;
    }
    if (typeof value === "object" && value.constructor === Object) {
        return datatypes_1.DataType.Object;
    }
    switch (typeof value) {
        case "bigint":
            return datatypes_1.DataType.UInt64;
        case "number":
            return datatypes_1.DataType.Float64;
        case "string":
            return datatypes_1.DataType.Utf8;
        case "boolean":
            return datatypes_1.DataType.Bool;
        default:
            return datatypes_1.DataType.Float64;
    }
};
exports.jsTypeToPolarsType = jsTypeToPolarsType;
/**
 * __finds the first non null value in the inputs__
 * ___
 * If the first value is an array
 * it will find the first scalar type in the array and return it wrapped into the array
 *
 * @example
 * ```
 * >>> const input = [null, [], [null, "a", "b"]]
 * >>> firstNonNull(input)
 * ["a"]
 * >>> const ints = [null, 1]
 * >>> firstNonNull(ints)
 * 1
 * ```
 */
const firstNonNull = (arr) => {
    const first = arr.find(x => x !== null && x !== undefined);
    if (Array.isArray(first)) {
        return [firstNonNull(arr.flat())];
    }
    return first;
};
/**
 * Construct an internal `JsSeries` from an array
 */
function arrayToJsSeries(name, values, dtype, strict = false) {
    if ((0, types_1.isTypedArray)(values)) {
        return polars_internal_1.default.series.new_from_typed_array({ name, values, strict });
    }
    //Empty sequence defaults to Float64 type
    if (!values.length && !dtype) {
        dtype = datatypes_1.DataType.Float64;
    }
    const firstValue = firstNonNull(values);
    if (Array.isArray(firstValue) || (0, types_1.isTypedArray)(firstValue)) {
        const listDtype = (0, exports.jsTypeToPolarsType)(firstValue);
        const constructor = (0, datatypes_1.polarsTypeToConstructor)(datatypes_1.DataType.List);
        return constructor({ name, values, strict, dtype: listDtype });
    }
    dtype = dtype ?? (0, exports.jsTypeToPolarsType)(firstValue);
    let series;
    if (firstValue instanceof Date) {
        series = polars_internal_1.default.series.new_opt_date({ name, values, strict });
    }
    else {
        const constructor = (0, datatypes_1.polarsTypeToConstructor)(dtype);
        series = constructor({ name, values, strict });
    }
    if ([datatypes_1.DataType.Datetime, datatypes_1.DataType.Date].includes(dtype)) {
        series = polars_internal_1.default.series.cast({ _series: series, dtype, strict: false });
    }
    return series;
}
exports.arrayToJsSeries = arrayToJsSeries;
function arrayToJsDataFrame(data, columns, orient) {
    let dataSeries;
    if (!data.length) {
        dataSeries = [];
    }
    else if (data[0]?._series) {
        dataSeries = [];
        data.forEach((series, idx) => {
            if (!series.name) {
                series.rename(`column_${idx}`, true);
            }
            dataSeries.push(series.inner());
        });
    }
    else if (data[0].constructor.name === "Object") {
        const df = polars_internal_1.default.df.read_rows({ rows: data });
        if (columns) {
            polars_internal_1.default.df.set_column_names({ _df: df, names: columns });
        }
        return df;
    }
    else if (Array.isArray(data[0])) {
        if (!orient && columns) {
            orient = columns.length === data.length ? "col" : "row";
        }
        if (orient === "row") {
            const df = polars_internal_1.default.df.read_array_rows({ data });
            columns && polars_internal_1.default.df.set_column_names({ _df: df, names: columns });
            return df;
        }
        else {
            dataSeries = data.map((s, idx) => (0, series_1.Series)(`column_${idx}`, s).inner());
        }
    }
    else {
        dataSeries = [(0, series_1.Series)("column_0", data).inner()];
    }
    dataSeries = handleColumnsArg(dataSeries, columns);
    return polars_internal_1.default.df.read_columns({ columns: dataSeries });
}
exports.arrayToJsDataFrame = arrayToJsDataFrame;
function handleColumnsArg(data, columns) {
    if (!columns) {
        return data;
    }
    else {
        if (!data) {
            return columns.map(c => (0, series_1.Series)(c, []).inner());
        }
        else if (data.length === columns.length) {
            columns.forEach((name, i) => {
                polars_internal_1.default.series.rename({ _series: data[i], name });
            });
            return data;
        }
    }
    throw new TypeError("Dimensions of columns arg must match data dimensions.");
}
