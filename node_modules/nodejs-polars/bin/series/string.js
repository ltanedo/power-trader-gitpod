"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StringFunctions = void 0;
const polars_internal_1 = __importDefault(require("../internals/polars_internal"));
const datatypes_1 = require("../datatypes");
const series_1 = require("../series");
const utils_1 = require("../utils");
const lazy_functions_1 = require("../lazy/lazy_functions");
const StringFunctions = (_s) => {
    const wrap = (method, args, _series = _s) => {
        return (0, series_1.seriesWrapper)(polars_internal_1.default.series.str[method]({ _series, ...args }));
    };
    return {
        concat(delimiter) {
            const s = (0, series_1.seriesWrapper)(_s);
            return s
                .toFrame()
                .select((0, lazy_functions_1.col)(s.name)
                .str
                .concat(delimiter)
                .as(s.name))
                .getColumn(s.name);
        },
        contains(pat) {
            return wrap("contains", { pat: (0, utils_1.regexToString)(pat) });
        },
        extract(pat, groupIndex) {
            return wrap("extract", { pat: (0, utils_1.regexToString)(pat), groupIndex });
        },
        jsonPathMatch(pat) {
            return wrap("jsonPathMatch", { pat });
        },
        lengths() {
            return wrap("lengths");
        },
        lstrip() {
            return wrap("replace", { pat: /^\s*/.source, val: "" });
        },
        replace(pat, val) {
            return wrap("replace", { pat: (0, utils_1.regexToString)(pat), val });
        },
        replaceAll(pat, val) {
            return wrap("replaceAll", { pat: (0, utils_1.regexToString)(pat), val });
        },
        rstrip() {
            return wrap("replace", { pat: /[ \t]+$/.source, val: "" });
        },
        slice(start, length) {
            return wrap("slice", { start, length });
        },
        strftime(dtype, fmt) {
            if (dtype === datatypes_1.DataType.Date) {
                return wrap("parseDate", { fmt });
            }
            else if (dtype === datatypes_1.DataType.Datetime) {
                return wrap("parseDateTime", { fmt });
            }
            else {
                throw new Error(`only "DataType.Date" and "DataType.Datetime" are supported`);
            }
        },
        toLowerCase() {
            return wrap("toLowerCase");
        },
        toUpperCase() {
            return wrap("toUpperCase");
        },
    };
};
exports.StringFunctions = StringFunctions;
