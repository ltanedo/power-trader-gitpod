"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GroupBy = void 0;
/* eslint-disable no-redeclare */
const dataframe_1 = require("./dataframe");
const utils = __importStar(require("./utils"));
const inspect = Symbol.for("nodejs.util.inspect.custom");
const util_1 = __importDefault(require("util"));
const error_1 = require("./error");
const lazy_functions_1 = require("./lazy/lazy_functions");
const inspectOpts = { colors: true, depth: null };
function GroupBy(df, by, maintainOrder = false, downsample = false, rule, downsampleN = 0) {
    const customInspect = () => util_1.default.formatWithOptions(inspectOpts, "GroupBy {by: %O}", by);
    const pivot = (opts, valuesCol) => {
        if (downsample) {
            throw new error_1.InvalidOperationError("pivot", "downsample");
        }
        if (typeof opts === "string") {
            if (valuesCol) {
                return pivot({ pivotCol: opts, valuesCol });
            }
            else {
                throw new Error("must specify both pivotCol and valuesCol");
            }
        }
        return PivotOps(df, by, opts.pivotCol, opts.valuesCol);
    };
    const select = (...columns) => {
        if (downsample) {
            throw new Error("select not supported in downsample operation");
        }
        return GroupBySelection(df, by, utils.columnOrColumnsStrict(columns));
    };
    const selectAll = () => GroupBySelection(df, by, undefined, downsample, rule, downsampleN);
    const agg = (...aggs) => {
        if (utils.isExprArray(aggs)) {
            aggs = [aggs].flat(2);
            return (0, dataframe_1.dfWrapper)(df).lazy()
                .groupBy(by, maintainOrder)
                .agg(...aggs)
                .collectSync({ noOptimization: true });
        }
        else {
            let pairs = Object.entries(aggs[0])
                .flatMap(([key, values]) => {
                return [values].flat(2).map(v => (0, lazy_functions_1.col)(key)[v]());
            });
            return (0, dataframe_1.dfWrapper)(df).lazy()
                .groupBy(by, maintainOrder)
                .agg(...pairs)
                .collectSync({ noOptimization: true });
        }
    };
    return Object.seal(Object.assign(select, {
        aggList: selectAll().aggList,
        agg,
        count: selectAll().count,
        first: selectAll().first,
        groups: () => (0, dataframe_1._wrapDataFrame)(df, "groupby", { by, agg: "groups" }),
        head: (n = 5) => { throw (0, error_1.todo)(); },
        last: selectAll().last,
        max: selectAll().max,
        mean: selectAll().mean,
        median: selectAll().median,
        min: selectAll().min,
        numUnique: selectAll().numUnique,
        pivot,
        quantile: selectAll().quantile,
        sum: selectAll().sum,
        tail: (n = 5) => { throw (0, error_1.todo)(); },
        [Symbol.isConcatSpreadable]: true,
        toString: () => "GroupBy",
        [inspect]: customInspect
    }));
}
exports.GroupBy = GroupBy;
function GroupBySelection(df, by, selection, downsample, rule, n) {
    const wrapCall = (agg) => () => {
        if (downsample) {
            return (0, dataframe_1._wrapDataFrame)(df, "downsample", { rule, n, agg });
        }
        else {
            return (0, dataframe_1._wrapDataFrame)(df, "groupby", { by, selection, agg });
        }
    };
    const quantile = (quantile) => {
        if (downsample) {
            throw new error_1.InvalidOperationError("quantile", "downsample");
        }
        else {
            return (0, dataframe_1._wrapDataFrame)(df, "groupby", { by, selection, agg: "quantile", quantile });
        }
    };
    const customInspect = () => util_1.default.formatWithOptions(inspectOpts, "GroupBySelection {by: %O}", by);
    return {
        [inspect]: customInspect,
        apply: (fn) => { throw (0, error_1.todo)(); },
        aggList: wrapCall("agg_list"),
        count: wrapCall("count"),
        first: wrapCall("first"),
        last: wrapCall("last"),
        max: wrapCall("max"),
        mean: wrapCall("mean"),
        median: wrapCall("median"),
        min: wrapCall("min"),
        numUnique: wrapCall("n_unique"),
        quantile,
        sum: wrapCall("sum"),
    };
}
function PivotOps(df, by, pivotCol, valueCol) {
    const pivot = (agg) => () => (0, dataframe_1._wrapDataFrame)(df, "pivot", { by, pivotCol, valueCol, agg });
    const customInspect = () => util_1.default.formatWithOptions(inspectOpts, "PivotOps {by: %O}", by);
    return {
        [inspect]: customInspect,
        first: pivot("first"),
        sum: pivot("sum"),
        min: pivot("min"),
        max: pivot("max"),
        mean: pivot("mean"),
        count: pivot("count"),
        median: pivot("median"),
    };
}
