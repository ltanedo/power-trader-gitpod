"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataFrame = exports._wrapDataFrame = exports.dfWrapper = void 0;
const polars_internal_1 = __importDefault(require("./internals/polars_internal"));
const construction_1 = require("./internals/construction");
const groupby_1 = require("./groupby");
const dataframe_1 = require("./lazy/dataframe");
const functions_1 = require("./functions");
const error_1 = require("./error");
const series_1 = require("./series");
const stream_1 = require("stream");
const datatypes_1 = require("./datatypes");
const utils_1 = require("./utils");
const inspect = Symbol.for("nodejs.util.inspect.custom");
function prepareOtherArg(anyValue) {
    if ((0, utils_1.isSeries)(anyValue)) {
        return anyValue;
    }
    else {
        return (0, series_1.Series)([anyValue]);
    }
}
function map(df, fn) {
    return df.rows().map(fn);
}
const dfWrapper = (_df) => {
    const unwrap = (method, args, df = _df) => {
        return polars_internal_1.default.df[method]({ _df: df, ...args });
    };
    const wrap = (method, args, df = _df) => {
        return (0, exports.dfWrapper)(unwrap(method, args, df));
    };
    const noArgWrap = (method) => () => wrap(method);
    const noArgUnwrap = (method) => () => unwrap(method);
    const df = {
        _df,
        [inspect]() {
            return unwrap("as_str");
        },
        *[Symbol.iterator]() {
            let start = 0;
            let len = this.height;
            while (start < len) {
                const s = this.toSeries(start);
                start++;
                yield s;
            }
        },
        get dtypes() {
            return unwrap("dtypes");
        },
        get height() {
            return unwrap("height");
        },
        get width() {
            return unwrap("width");
        },
        get shape() {
            return { height: this.height, width: this.width };
        },
        get columns() {
            return unwrap("columns");
        },
        inner: () => _df,
        clone: noArgWrap("clone"),
        describe() {
            const describeCast = (df) => {
                return DataFrame(df.getColumns().map(s => {
                    if (s.isNumeric() || s.isBoolean()) {
                        return s.cast(datatypes_1.DataType.Float64);
                    }
                    else {
                        return s;
                    }
                }));
            };
            const summary = (0, functions_1.concat)([
                describeCast(this.mean()),
                describeCast(this.std()),
                describeCast(this.min()),
                describeCast(this.max()),
                describeCast(this.median())
            ]);
            summary.insertAtIdx(0, (0, series_1.Series)("describe", ["mean", "std", "min", "max", "median"]));
            return summary;
        },
        downsample: (opt, rule, n) => (0, groupby_1.GroupBy)(_df, opt?.by ?? opt, true, opt?.rule ?? rule, opt?.n ?? n),
        drop(name, ...names) {
            names.unshift(name);
            if (!Array.isArray(names[0]) && names.length === 1) {
                return wrap("drop", { name: names[0] });
            }
            const df = this.clone();
            names.flat(2).forEach((name) => {
                unwrap("drop_in_place", { name }, df._df);
            });
            return df;
        },
        dropNulls(...subset) {
            if (subset.length) {
                return wrap("drop_nulls", { subset: subset.flat(2) });
            }
            else {
                return wrap("drop_nulls");
            }
        },
        dropDuplicates(opts = true, subset) {
            if (opts?.maintainOrder !== undefined) {
                return this.dropDuplicates(opts.maintainOrder, opts.subset);
            }
            if (subset) {
                subset = [subset].flat(2);
            }
            return wrap("drop_duplicates", { maintainOrder: opts.maintainOrder, subset });
        },
        explode(...columns) {
            return (0, exports.dfWrapper)(_df).lazy()
                .explode(columns)
                .collectSync({ noOptimization: true });
        },
        filter(predicate) {
            return this
                .lazy()
                .filter(predicate)
                .collectSync();
        },
        fillNull: (strategy) => wrap("fill_null", { strategy }),
        findIdxByName: (name) => unwrap("find_idx_by_name", { name }),
        fold(fn) {
            if (this.width === 1) {
                return this.toSeries(0);
            }
            return this.getColumns().reduce((acc, curr) => fn(acc, curr));
        },
        frameEqual(other, nullEqual = true) {
            return unwrap("frame_equal", { other: other._df, nullEqual });
        },
        getColumn(name) {
            return (0, series_1.seriesWrapper)(unwrap("column", { name }));
        },
        getColumns() {
            return unwrap("get_columns").map(s => (0, series_1.seriesWrapper)(s));
        },
        groupBy: (...by) => (0, groupby_1.GroupBy)(_df, (0, utils_1.columnOrColumnsStrict)(by)),
        hashRows(obj = 0, k1 = 1, k2 = 2, k3 = 3) {
            if (typeof obj === "number" || typeof obj === "bigint") {
                return (0, series_1.seriesWrapper)(unwrap("hash_rows", { k0: obj, k1: k1, k2: k2, k3: k3 }));
            }
            return (0, series_1.seriesWrapper)(unwrap("hash_rows", { k0: 0, k1, k2, k3, ...obj }));
        },
        head: (length = 5) => wrap("head", { length }),
        hstack(columns) {
            if (!Array.isArray(columns)) {
                columns = columns.getColumns();
            }
            return wrap("hstack", {
                columns: columns.map(col => col._series),
                in_place: false
            });
        },
        insertAtIdx: (index, s) => unwrap("insert_at_idx", { index, new_col: s._series }),
        interpolate: noArgWrap("interpolate"),
        isDuplicated: () => (0, series_1.seriesWrapper)(unwrap("is_duplicated")),
        isEmpty: () => unwrap("height") === 0,
        isUnique: () => (0, series_1.seriesWrapper)(unwrap("is_unique")),
        join(df, options) {
            options = { how: "inner", suffix: "right", ...options };
            const on = (0, utils_1.columnOrColumns)(options.on);
            const how = options.how;
            const suffix = options.suffix;
            let leftOn = (0, utils_1.columnOrColumns)(options.leftOn);
            let rightOn = (0, utils_1.columnOrColumns)(options.rightOn);
            if (on) {
                leftOn = on;
                rightOn = on;
            }
            if ((leftOn && !rightOn) || (rightOn && !leftOn)) {
                throw new TypeError("You should pass the column to join on as an argument.");
            }
            return wrap("join", {
                other: df._df,
                on,
                how,
                left_on: leftOn,
                right_on: rightOn,
                suffix,
            });
        },
        lazy: () => (0, dataframe_1.LazyDataFrame)(unwrap("lazy")),
        limit: (length = 5) => wrap("head", { length }),
        max(axis = 0) {
            if (axis === 1) {
                return (0, series_1.seriesWrapper)(unwrap("hmax"));
            }
            else {
                return wrap("max");
            }
        },
        mean(axis = 0, nullStrategy = "ignore") {
            if (axis === 1) {
                return (0, series_1.seriesWrapper)(unwrap("hmean", { nullStrategy }));
            }
            return wrap("mean");
        },
        median: noArgWrap("median"),
        melt(ids, values) {
            return wrap("melt", {
                idVars: (0, utils_1.columnOrColumns)(ids),
                valueVars: (0, utils_1.columnOrColumns)(values)
            });
        },
        min(axis = 0) {
            if (axis === 1) {
                return (0, series_1.seriesWrapper)(unwrap("hmin"));
            }
            else {
                return wrap("min");
            }
        },
        nChunks: noArgUnwrap("n_chunks"),
        nullCount: noArgWrap("null_count"),
        quantile: (quantile) => wrap("quantile", { quantile }),
        rechunk: noArgWrap("rechunk"),
        rename(mapping) {
            const df = this.clone();
            Object.entries(mapping).forEach(([column, new_col]) => {
                unwrap("rename", { column, new_col }, df._df);
            });
            return df;
        },
        replaceAtIdx(index, newColumn) {
            unwrap("replace_at_idx", {
                index,
                newColumn: newColumn._series
            });
            return this;
        },
        rows: noArgUnwrap("to_rows"),
        sample(opts, frac, withReplacement = false) {
            if (opts?.n !== undefined || opts?.frac !== undefined) {
                return this.sample(opts.n, opts.frac, opts.withReplacement);
            }
            if (typeof opts === "number") {
                return wrap("sample_n", {
                    n: opts,
                    withReplacement
                });
            }
            if (typeof frac === "number") {
                return wrap("sample_frac", {
                    frac,
                    withReplacement,
                });
            }
            else {
                throw new TypeError("must specify either 'frac' or 'n'");
            }
        },
        schema: noArgUnwrap("schema"),
        select(...selection) {
            const hasExpr = selection.flat().some(s => (0, utils_1.isExpr)(s));
            if (hasExpr) {
                return (0, exports.dfWrapper)(_df)
                    .lazy()
                    .select(selection)
                    .collectSync();
            }
            else {
                return wrap("select", { selection: (0, utils_1.columnOrColumnsStrict)(selection) });
            }
        },
        shift: (opt) => wrap("shift", { periods: opt?.periods ?? opt }),
        shiftAndFill(periods, fillValue) {
            return (0, exports.dfWrapper)(_df)
                .lazy()
                .shiftAndFill(periods, fillValue)
                .collectSync();
        },
        shrinkToFit(inPlace = false) {
            if (inPlace) {
                unwrap("shrink_to_fit");
            }
            else {
                const d = this.clone();
                unwrap("shrink_to_fit", {}, d._df);
                return d;
            }
        },
        slice(opts, length) {
            if (typeof opts === "number") {
                return wrap("slice", { offset: opts, length });
            }
            return wrap("slice", opts);
        },
        sort(arg, reverse = false) {
            if (arg?.by !== undefined) {
                return this.sort(arg.by, arg.reverse);
            }
            if (Array.isArray(arg) || (0, utils_1.isExpr)(arg)) {
                return (0, exports.dfWrapper)(_df).lazy()
                    .sort(arg, reverse)
                    .collectSync({ noOptimization: true, stringCache: false });
            }
            return wrap("sort", { by: arg, reverse });
        },
        std: noArgWrap("std"),
        sum(axis = 0, nullStrategy = "ignore") {
            if (axis === 1) {
                return (0, series_1.seriesWrapper)(unwrap("hsum", { nullStrategy }));
            }
            return wrap("sum");
        },
        tail: (length = 5) => wrap("tail", { length }),
        toCSV(dest, options) {
            options = { hasHeader: true, sep: ",", ...options };
            if (dest instanceof stream_1.Stream.Writable) {
                unwrap("write_csv_stream", { writeStream: dest, ...options });
            }
            else if (typeof dest === "string") {
                unwrap("write_csv", { path: dest, ...options });
            }
            else if (!dest || (dest.constructor.name === "Object" && !dest["dest"])) {
                let body = "";
                const writeStream = new stream_1.Stream.Writable({
                    write(chunk, _encoding, callback) {
                        body += chunk;
                        callback(null);
                    }
                });
                unwrap("write_csv_stream", { writeStream, ...options, ...dest });
                return body;
            }
            else {
                throw new TypeError("unknown destination type, Supported types are 'string' and 'Stream.Writeable'");
            }
        },
        toJS(options) {
            if (options?.orient === "row") {
                const columns = this.columns;
                const rows = this.rows();
                return rows.map(row => {
                    return row.reduce((acc, curr, currIdx) => ({
                        [columns[currIdx]]: curr,
                        ...acc
                    }));
                });
            }
            if (options?.orient === "literal") {
                return unwrap("to_js");
            }
            return unwrap("get_columns").reduce((acc, curr) => {
                const s = (0, series_1.seriesWrapper)(curr);
                return {
                    ...acc,
                    [s.name]: s.toArray()
                };
            }, {});
        },
        toJSON(arg0, options) {
            if (arg0 === "") {
                return this.toJS({ orient: "literal", ...options });
            }
            return this.__toJSON(arg0);
        },
        __toJSON(dest) {
            if (dest instanceof stream_1.Stream.Writable) {
                unwrap("write_json_stream", { writeStream: dest });
            }
            else if (typeof dest === "string" && dest.length) {
                unwrap("write_json", { path: dest });
            }
            else if (!dest) {
                let body = "";
                const writeStream = new stream_1.Stream.Writable({
                    write(chunk, _encoding, callback) {
                        body += chunk;
                        callback(null);
                    }
                });
                unwrap("write_json_stream", { writeStream });
                return body;
            }
            else {
                throw new TypeError("unknown destination type, Supported types are 'string' and 'Stream.Writeable'");
            }
        },
        toSeries: (index) => (0, series_1.seriesWrapper)(unwrap("select_at_idx", { index })),
        toString: noArgUnwrap("as_str"),
        add: (other) => wrap("add", { other: prepareOtherArg(other)._series }),
        sub: (other) => wrap("sub", { other: prepareOtherArg(other)._series }),
        div: (other) => wrap("div", { other: prepareOtherArg(other)._series }),
        mul: (other) => wrap("mul", { other: prepareOtherArg(other)._series }),
        rem: (other) => wrap("rem", { other: prepareOtherArg(other)._series }),
        plus: (other) => wrap("add", { other: prepareOtherArg(other)._series }),
        minus: (other) => wrap("sub", { other: prepareOtherArg(other)._series }),
        divideBy: (other) => wrap("div", { other: prepareOtherArg(other)._series }),
        multiplyBy: (other) => wrap("mul", { other: prepareOtherArg(other)._series }),
        modulo: (other) => wrap("rem", { other: prepareOtherArg(other)._series }),
        var: noArgWrap("var"),
        apply: () => { throw (0, error_1.todo)(); },
        map: (fn) => map((0, exports.dfWrapper)(_df), fn),
        pipe: (fn) => { throw (0, error_1.todo)(); },
        row: (index) => unwrap("to_row", { idx: index }),
        upsample: (index) => { throw (0, error_1.todo)(); },
        vstack: (other) => wrap("vstack", { other: other._df }),
        withColumn(column) {
            if ((0, utils_1.isSeries)(column)) {
                return wrap("with_column", { _series: column._series });
            }
            else {
                return this.withColumns(column);
            }
        },
        withColumns(column, ...columns) {
            columns.unshift(column);
            if ((0, utils_1.isSeriesArray)(columns)) {
                return columns.reduce((acc, curr) => acc.withColumn(curr), (0, exports.dfWrapper)(_df));
            }
            else {
                return this
                    .lazy()
                    .withColumns(columns)
                    .collectSync({ noOptimization: true, stringCache: false });
            }
        },
        withColumnRenamed(opt, replacement) {
            if (typeof opt === "string") {
                return this.rename({ [opt]: replacement });
            }
            else {
                return this.rename({ [opt.existing]: opt.replacement });
            }
        },
        withRowCount: (name = "row_nr") => wrap("with_row_count", { name }),
        where(predicate) {
            return this.filter(predicate);
        }
    };
    return new Proxy(df, {
        get: function (target, prop, receiver) {
            if (typeof prop === "string" && target.columns.includes(prop)) {
                return target.getColumn(prop);
            }
            if (Array.isArray(prop) && target.columns.includes(prop[0])) {
                return target.select(prop);
            }
            if (typeof prop !== "symbol" && !Number.isNaN(Number(prop))) {
                return target.row(Number(prop));
            }
            else {
                return Reflect.get(target, prop, receiver);
            }
        },
        has: function (target, p) {
            return target.columns.includes(p);
        }
    });
};
exports.dfWrapper = dfWrapper;
const _wrapDataFrame = (df, method, args) => (0, exports.dfWrapper)(polars_internal_1.default.df[method]({ _df: df, ...args }));
exports._wrapDataFrame = _wrapDataFrame;
function DataFrame(data, options) {
    if (!data) {
        return (0, exports.dfWrapper)(objToDF({}));
    }
    if (Array.isArray(data)) {
        return (0, exports.dfWrapper)((0, construction_1.arrayToJsDataFrame)(data, options?.columns, options?.orient));
    }
    return (0, exports.dfWrapper)(objToDF(data));
}
exports.DataFrame = DataFrame;
function objToDF(obj) {
    const columns = Object.entries(obj).map(([key, value]) => (0, series_1.Series)(key, value)._series);
    return polars_internal_1.default.df.read_columns({ columns });
}
