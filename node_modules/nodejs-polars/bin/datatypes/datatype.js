"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TimeUnit = exports.Struct = exports.FixedSizeList = exports.List = exports.Datetime = exports.Decimal = exports.Categorical = exports.String = exports.Utf8 = exports.Object_ = exports.Time = exports.Date = exports.Float64 = exports.Float32 = exports.UInt64 = exports.UInt32 = exports.UInt16 = exports.UInt8 = exports.Int64 = exports.Int32 = exports.Int16 = exports.Int8 = exports.Bool = exports.Null = exports.DataType = void 0;
const field_1 = require("./field");
class DataType {
    get variant() {
        return this.constructor.name;
    }
    identity = "DataType";
    get inner() {
        return null;
    }
    equals(other) {
        return (this.variant === other.variant &&
            this.inner === null &&
            other.inner === null);
    }
    /** Null type */
    static get Null() {
        return new Null();
    }
    /** `true` and `false`. */
    static get Bool() {
        return new Bool();
    }
    /** An `i8` */
    static get Int8() {
        return new Int8();
    }
    /** An `i16` */
    static get Int16() {
        return new Int16();
    }
    /** An `i32` */
    static get Int32() {
        return new Int32();
    }
    /** An `i64` */
    static get Int64() {
        return new Int64();
    }
    /** An `u8` */
    static get UInt8() {
        return new UInt8();
    }
    /** An `u16` */
    static get UInt16() {
        return new UInt16();
    }
    /** An `u32` */
    static get UInt32() {
        return new UInt32();
    }
    /** An `u64` */
    static get UInt64() {
        return new UInt64();
    }
    /** A `f32` */
    static get Float32() {
        return new Float32();
    }
    /** A `f64` */
    static get Float64() {
        return new Float64();
    }
    static get Date() {
        return new Date();
    }
    /** Time of day type */
    static get Time() {
        return new Time();
    }
    /** Type for wrapping arbitrary JS objects */
    static get Object() {
        return new Object_();
    }
    /** A categorical encoding of a set of strings  */
    static get Categorical() {
        return new Categorical();
    }
    /** Decimal type */
    static Decimal(precision, scale) {
        return new Decimal(precision, scale);
    }
    /**
     * Calendar date and time type
     * @param timeUnit any of 'ms' | 'ns' | 'us'
     * @param timeZone timezone string as defined by Intl.DateTimeFormat `America/New_York` for example.
     */
    static Datetime(timeUnit, timeZone = null) {
        return new Datetime(timeUnit ?? "ms", timeZone);
    }
    /**
     * Nested list/array type
     *
     * @param inner The `DataType` of values within the list
     *
     */
    static List(inner) {
        return new List(inner);
    }
    /**
     * List of fixed length
     * This is called `Array` in other polars implementations, but `Array` is widely used in JS, so we use `FixedSizeList` instead.
     *
     */
    static FixedSizeList(inner, listSize) {
        return new FixedSizeList(inner, listSize);
    }
    static Struct(fields) {
        return new Struct(fields);
    }
    /** A variable-length UTF-8 encoded string whose offsets are represented as `i64`. */
    static get Utf8() {
        return new Utf8();
    }
    static get String() {
        return new String();
    }
    toString() {
        if (this.inner) {
            return `${this.identity}(${this.variant}(${this.inner}))`;
        }
        return `${this.identity}(${this.variant})`;
    }
    toJSON() {
        const inner = this.inner;
        if (inner) {
            return {
                [this.identity]: {
                    [this.variant]: inner[0],
                },
            };
        }
        return {
            [this.identity]: this.variant,
        };
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
        return this.toString();
    }
    asFixedSizeList() {
        if (this instanceof FixedSizeList) {
            return this;
        }
        return null;
    }
}
exports.DataType = DataType;
class Null extends DataType {
}
exports.Null = Null;
class Bool extends DataType {
}
exports.Bool = Bool;
class Int8 extends DataType {
}
exports.Int8 = Int8;
class Int16 extends DataType {
}
exports.Int16 = Int16;
class Int32 extends DataType {
}
exports.Int32 = Int32;
class Int64 extends DataType {
}
exports.Int64 = Int64;
class UInt8 extends DataType {
}
exports.UInt8 = UInt8;
class UInt16 extends DataType {
}
exports.UInt16 = UInt16;
class UInt32 extends DataType {
}
exports.UInt32 = UInt32;
class UInt64 extends DataType {
}
exports.UInt64 = UInt64;
class Float32 extends DataType {
}
exports.Float32 = Float32;
class Float64 extends DataType {
}
exports.Float64 = Float64;
// biome-ignore lint/suspicious/noShadowRestrictedNames: <explanation>
class Date extends DataType {
}
exports.Date = Date;
class Time extends DataType {
}
exports.Time = Time;
class Object_ extends DataType {
}
exports.Object_ = Object_;
class Utf8 extends DataType {
}
exports.Utf8 = Utf8;
// biome-ignore lint/suspicious/noShadowRestrictedNames: <explanation>
class String extends DataType {
}
exports.String = String;
class Categorical extends DataType {
}
exports.Categorical = Categorical;
class Decimal extends DataType {
    precision;
    scale;
    constructor(precision, scale) {
        super();
        this.precision = precision ?? null;
        this.scale = scale ?? null;
    }
    get inner() {
        return [this.precision, this.scale];
    }
    equals(other) {
        if (other.variant === this.variant) {
            return (this.precision === other.precision &&
                this.scale === other.scale);
        }
        return false;
    }
    toJSON() {
        return {
            [this.identity]: {
                [this.variant]: {
                    precision: this.precision,
                    scale: this.scale,
                },
            },
        };
    }
}
exports.Decimal = Decimal;
/**
 * Datetime type
 */
class Datetime extends DataType {
    timeUnit;
    timeZone;
    constructor(timeUnit = "ms", timeZone) {
        super();
        this.timeUnit = timeUnit;
        this.timeZone = timeZone;
    }
    get inner() {
        return [this.timeUnit, this.timeZone];
    }
    equals(other) {
        if (other.variant === this.variant) {
            return (this.timeUnit === other.timeUnit &&
                this.timeZone === other.timeZone);
        }
        return false;
    }
}
exports.Datetime = Datetime;
class List extends DataType {
    __inner;
    constructor(__inner) {
        super();
        this.__inner = __inner;
    }
    get inner() {
        return [this.__inner];
    }
    equals(other) {
        if (other.variant === this.variant) {
            return this.inner[0].equals(other.inner[0]);
        }
        return false;
    }
}
exports.List = List;
class FixedSizeList extends DataType {
    __inner;
    listSize;
    constructor(__inner, listSize) {
        super();
        this.__inner = __inner;
        this.listSize = listSize;
    }
    get inner() {
        return [this.__inner, this.listSize];
    }
    equals(other) {
        if (other.variant === this.variant) {
            return (this.inner[0].equals(other.inner[0]) &&
                this.inner[1] === other.inner[1]);
        }
        return false;
    }
    toJSON() {
        return {
            [this.identity]: {
                [this.variant]: {
                    type: this.inner[0].toJSON(),
                    size: this.inner[1],
                },
            },
        };
    }
}
exports.FixedSizeList = FixedSizeList;
class Struct extends DataType {
    fields;
    constructor(inner) {
        super();
        if (Array.isArray(inner)) {
            this.fields = inner;
        }
        else {
            this.fields = Object.entries(inner).map(field_1.Field.from);
        }
    }
    get inner() {
        return this.fields;
    }
    equals(other) {
        if (other.variant === this.variant) {
            return this.inner
                .map((fld, idx) => {
                const otherfld = other.fields[idx];
                return otherfld.name === fld.name && otherfld.dtype.equals(fld.dtype);
            })
                .every((value) => value);
        }
        return false;
    }
    toJSON() {
        return {
            [this.identity]: {
                [this.variant]: this.fields,
            },
        };
    }
}
exports.Struct = Struct;
/**
 * Datetime time unit
 */
var TimeUnit;
(function (TimeUnit) {
    TimeUnit["Nanoseconds"] = "ns";
    TimeUnit["Microseconds"] = "us";
    TimeUnit["Milliseconds"] = "ms";
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));
/**
 * @ignore
 * Timeunit namespace
 */
(function (TimeUnit) {
    function from(s) {
        return TimeUnit[s];
    }
    TimeUnit.from = from;
})(TimeUnit || (exports.TimeUnit = TimeUnit = {}));
/**
 * Datatype namespace
 */
(function (DataType) {
    /**
     * deserializes a datatype from the serde output of rust polars `DataType`
     * @param dtype dtype object
     */
    function deserialize(dtype) {
        if (typeof dtype === "string") {
            return DataType[dtype];
        }
        let { variant, inner } = dtype;
        if (variant === "Struct") {
            inner = [
                inner[0].map((fld) => field_1.Field.from(fld.name, deserialize(fld.dtype))),
            ];
        }
        if (variant === "List") {
            inner = [deserialize(inner[0])];
        }
        if (variant === "FixedSizeList") {
            inner = [deserialize(inner[0]), inner[1]];
        }
        return DataType[variant](...inner);
    }
    DataType.deserialize = deserialize;
})(DataType || (exports.DataType = DataType = {}));
